<!DOCTYPE html>
<html>
<head>
		<script>
				var c;
			  var mx,my,mb=0;
			
// https://en.wikipedia.org/wiki/Fortune%27s_algorithm
// https://jacquesheunis.com/post/fortunes-algorithm/
// https://www.youtube.com/watch?v=I6Fen2Ac-1U
// https://codeforces.com/blog/entry/85638
// https://link.springer.com/article/10.1007/s41095-022-0326-0#preview
// https://cp-algorithms.com/geometry/delaunay.html
// https://www.codeproject.com/Articles/882739/Simple-Approach-to-Voronoi-Diagrams
// https://www.youtube.com/watch?v=pUwEp1hs8MM
// https://algo.uni-trier.de/lectures/algeo/slides/
// https://www.youtube.com/watch?v=Pn19deUBsM8&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=1
// https://www.youtube.com/watch?v=pUwEp1hs8MM&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=4
// http://www.bitbanging.space/posts/voronoi-diagram-with-fortunes-algorithm
// http://www.paul-reed.co.uk/fortune.htm#parabolaequation
// https://github.com/PaulMakesStuff/Voronoi2D/blob/master/Voronoi.js
// https://github.com/ridoluc/Voronoi-Diagram/blob/master/Voronoi.js
// https://jacquesheunis.com/post/fortunes-algorithm/
// https://algo.uni-trier.de/lectures/algeo/slides/

// line intercect math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
// Determine the intersection point of two line segments - modified to test intersection between line and ray
function intersect(p1,p2,p3,p4) {
    // Check if none of the lines are of length 0
    if ((p1.x === p2.x && p1.y === p2.y) || (p3.x === p4.x && p3.y === p4.y)) return false;

    denominator = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));

    // Lines are parallel
    if (denominator === 0) return false;

    let ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    let ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    if (ua < 0 || ua > 1) {
        return false
    }

    // Return a object with the x and y coordinates of the intersection
    let x = p1.x + ua * (p2.x - p1.x);
    let y = p1.y + ua * (p2.y - p1.y);

    return {x:x, y:y}
}

// Inside polygon using even odd rule
function insidePoly(pointlist,pnt)
{
    var cnt=0;
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];    
        if((pnt.y>=p1.y&&pnt.y<p2.y)||(pnt.y>=p2.y&&pnt.y<p1.y)){
            var dx=p2.x-p1.x;
            var dy=p2.y-p1.y;
            var k=dx/dy;
            var m=p1.x-(k*p1.y);
            if(((k*pnt.y)+m)<=pnt.x) cnt++
        }
    }        
    return cnt%2;
}

// Draw the polygon outline with a certain color
function drawPolygon(pointlist)
{
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];
        drawLine(p1,p2,"#25e");
    }
}

// Draw a line with a certain color
function drawLine(p1,p2,color)
{
    c.strokeStyle=color;
    c.beginPath();
    c.moveTo(p1.x,p1.y);
    c.lineTo(p2.x,p2.y);
    c.stroke();
}

// Intersection of pointlist polygon and ray
function intersectPolygon(pointlist,r1,r2,q)
{
    // Return array
    var retarr=[];
    var foundarr=[];
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];
        col=intersect(p1,p2,r1,r2);

        // If an intersection is found we store the point and the position of the intersection
        if(col!=false){
            foundarr.push({x:col.x,y:col.y,pos:i});
        }
    }
    
    if(foundarr.length==2){
        // Make first array and check if point is inside array
        var newarr=[];
        for(var i=0;i<=foundarr[0].pos;i++){
            newarr.push(pointlist[i]);
        }
        newarr.push({x:foundarr[0].x,y:foundarr[0].y});
        newarr.push({x:foundarr[1].x,y:foundarr[1].y});
        for(var i=foundarr[1].pos+1;i<pointlist.length;i++){
            newarr.push(pointlist[i]);
        }

        if(insidePoly(newarr,q)){
            return newarr;
        }

        // Make alternate array
        var otherarr=[];
        otherarr.push({x:foundarr[0].x,y:foundarr[0].y});
        for(var i=foundarr[0].pos+1;i<=foundarr[1].pos;i++){
            otherarr.push(pointlist[i]);
        }
        otherarr.push({x:foundarr[1].x,y:foundarr[1].y});
        return otherarr;

    }else{
        return false;
    }
}

function zetup()
{
		var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");
    updatestate();
}
				
function updatestate()
{
    var poly=[{x:20,y:20},{x:220,y:20},{x:220,y:220},{x:20,y:220}];
    
    var r1={x:40,y:30};
    var r2={x:140,y:210};
    var q={x:30,y:70};

    var intersected=intersectPolygon(poly,r1,r2,q);
    if(intersected!=null) drawPolygon(intersected);
}		
			
		</script>
</head>
<body onload="zetup();">
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas> 
  <button onclick="generate();">Render</button>
</body>
