<!DOCTYPE html>
<html>
<head>
		<script>
				var c;
			  var mx,my,mb=0;
			
// https://en.wikipedia.org/wiki/Fortune%27s_algorithm
// https://jacquesheunis.com/post/fortunes-algorithm/
// https://www.youtube.com/watch?v=I6Fen2Ac-1U
// https://codeforces.com/blog/entry/85638
// https://link.springer.com/article/10.1007/s41095-022-0326-0#preview
// https://cp-algorithms.com/geometry/delaunay.html
// https://www.codeproject.com/Articles/882739/Simple-Approach-to-Voronoi-Diagrams
// https://www.youtube.com/watch?v=pUwEp1hs8MM
// https://algo.uni-trier.de/lectures/algeo/slides/
// https://www.youtube.com/watch?v=Pn19deUBsM8&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=1
// https://www.youtube.com/watch?v=pUwEp1hs8MM&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=4
// http://www.bitbanging.space/posts/voronoi-diagram-with-fortunes-algorithm
// http://www.paul-reed.co.uk/fortune.htm#parabolaequation
// https://github.com/PaulMakesStuff/Voronoi2D/blob/master/Voronoi.js
// https://github.com/ridoluc/Voronoi-Diagram/blob/master/Voronoi.js
// https://algo.uni-trier.de/lectures/algeo/slides/
// https://www.youtube.com/watch?v=3G5d8ob_Lfo&t=15s

// line intercect math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
// Determine the intersection point of two line segments - modified to test intersection between line and ray
function intersect(p1,p2,p3,p4) {
    // Check if none of the lines are of length 0
    if ((p1.x === p2.x && p1.y === p2.y) || (p3.x === p4.x && p3.y === p4.y)) return false;

    denominator = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));

    // Lines are parallel
    if (denominator === 0) return false;

    let ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    let ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    if (ua < 0 || ua > 1) {
        return false
    }

    // Return a object with the x and y coordinates of the intersection
    let x = p1.x + ua * (p2.x - p1.x);
    let y = p1.y + ua * (p2.y - p1.y);

    return {x:x, y:y}
}

// Inside polygon using even odd rule
function insidePoly(pointlist,pnt)
{
    var cnt=0;
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];    
        if((pnt.y>=p1.y&&pnt.y<p2.y)||(pnt.y>=p2.y&&pnt.y<p1.y)){
            var dx=p2.x-p1.x;
            var dy=p2.y-p1.y;
            var k=dx/dy;
            var m=p1.x-(k*p1.y);
            if(((k*pnt.y)+m)<=pnt.x) cnt++
        }
    }        
    return cnt%2;
}

// Draw the polygon outline with a certain color
function drawPolygon(pointlist,color)
{
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];
        drawLine(p1,p2,color);
    }
}

// Draw a line with a certain color
function drawLine(p1,p2,color)
{
    c.strokeStyle=color;
    c.beginPath();
    c.moveTo(p1.x,p1.y);
    c.lineTo(p2.x,p2.y);
    c.stroke();
}

function drawPointList(pointlist,pointcolor,textcolor,textsize)
{
    c.textAlign="center";
    c.font = textsize+"px Arial Narrow";
    c.textBaseline="bottom";
    for(point of pointlist){
        c.fillStyle=pointcolor;
        c.beginPath();
        c.arc(point.x,point.y,5,0,Math.PI*2.0);
        c.fill();
        c.fillStyle=textcolor;        
        c.fillText("("+point.x+","+point.y+")", point.x,point.y-5.0);
    }
}

// Intersection of pointlist polygon and ray
function intersectPolygon(pointlist,r1,r2,q)
{
    // Return array
    var retarr=[];
    var foundarr=[];
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];
        col=intersect(p1,p2,r1,r2);

        // If an intersection is found we store the point and the position of the intersection
        if(col!=false){
            foundarr.push({x:col.x,y:col.y,pos:i});
            //c.beginPath();
            //c.arc(col.x,col.y,5,0,Math.PI*2.0);
            //c.fill();
        }
    }
    
    if(foundarr.length==2){
        // Make first array of points before intersection
        var newarr=[];
        for(var i=0;i<=foundarr[0].pos;i++){
            newarr.push(pointlist[i]);
        }
        newarr.push({x:foundarr[0].x,y:foundarr[0].y});
        newarr.push({x:foundarr[1].x,y:foundarr[1].y});
        for(var i=foundarr[1].pos+1;i<pointlist.length;i++){
            newarr.push(pointlist[i]);
        }

        // Check if point is inside array
        if(insidePoly(newarr,q)){
            return newarr;
        }

        // Make alternate array
        var otherarr=[];
        otherarr.push({x:foundarr[0].x,y:foundarr[0].y});
        for(var i=foundarr[0].pos+1;i<=foundarr[1].pos;i++){
            otherarr.push(pointlist[i]);
        }
        otherarr.push({x:foundarr[1].x,y:foundarr[1].y});
        return otherarr;

    }else{
        return null;
    }
}

function zetup()
{
		var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");
    updatestate();
}

const maxExtent=10000;
function processPoints(pointlist,treshold)
{
    // We first find extents including offsets
    var x1=maxExtent;
    var x2=-maxExtent;
    var y1=maxExtent;
    var y2=-maxExtent;
    for(point of pointlist){
        x1=Math.min(x1,point.x-treshold);
        x2=Math.max(x2,point.x+treshold);
        y1=Math.min(y1,point.y-treshold);
        y2=Math.max(y2,point.y+treshold);    
    }

    var polypoints=[{x:x1,y:y1},{x:x2,y:y1},{x:x2,y:y2},{x:x1,y:y2}];

    // For each point except for first
    for(var i=1;i<pointlist.length;i++){
        p1={x:(pointlist[0].x+pointlist[i].x)*0.5,y:(pointlist[0].y+pointlist[i].y)*0.5};
        p2={x:p1.x-(pointlist[0].y-pointlist[i].y),y:p1.y+(pointlist[0].x-pointlist[i].x)};
        var intersected=intersectPolygon(polypoints,p1,p2,pointlist[0]);
        if(intersected!=null) polypoints=intersected;
        // drawLine(pointlist[0],pointlist[i],"#606");
    }

    return polypoints;
}

function updatestate()
{
    // Input points from https://codeforces.com/blog/entry/85638
    var pointlist=[{x:266,y:468},{x:356,y:297},{x:209,y:130},{x:442,y:112},{x:700,y:75},{x:81,y:344},{x:617,y:260},{x:75,y:558},{x:473,y:468},{x:723,y:458},{x:590,y:622}];

    // First step, processing a list of points
    drawPointList(pointlist,"#25e","#000",16);

    var voronoipolygons=[];
 
    for(var i=0;i<pointlist.length;i++){
        var pp=pointlist.pop();
        pointlist.unshift(pp);
        voronoipolygons.push(processPoints(pointlist,20));
    }

    for(polygon of voronoipolygons){
        drawPolygon(polygon,"#0f0");
    }
}		
			
		</script>
</head>
<body onload="zetup();">
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas> 
  <button onclick="generate();">Render</button>
</body>