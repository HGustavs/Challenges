<!DOCTYPE html>
<html>
<head>
    <script src="helperFunction/hexcolors.js"></script>
    <script src="helperFunction/spatialHash.js"></script>
    <script src="helperFunction/canvasDraw.js"></script>

		<script>
				var c;
			  var mx,my,mb=0;
        var testcnt=0;
			
// https://en.wikipedia.org/wiki/Fortune%27s_algorithm
// https://jacquesheunis.com/post/fortunes-algorithm/
// https://www.youtube.com/watch?v=I6Fen2Ac-1U
// https://codeforces.com/blog/entry/85638
// https://link.springer.com/article/10.1007/s41095-022-0326-0#preview
// https://cp-algorithms.com/geometry/delaunay.html
// https://www.codeproject.com/Articles/882739/Simple-Approach-to-Voronoi-Diagrams
// https://www.youtube.com/watch?v=pUwEp1hs8MM
// https://algo.uni-trier.de/lectures/algeo/slides/
// https://www.youtube.com/watch?v=Pn19deUBsM8&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=1
// https://www.youtube.com/watch?v=pUwEp1hs8MM&list=PLubYOWSl9mIuUsLBKM4NIzPrmBA5jKL-r&index=4
// http://www.bitbanging.space/posts/voronoi-diagram-with-fortunes-algorithm
// http://www.paul-reed.co.uk/fortune.htm#parabolaequation
// https://github.com/PaulMakesStuff/Voronoi2D/blob/master/Voronoi.js
// https://github.com/ridoluc/Voronoi-Diagram/blob/master/Voronoi.js
// https://algo.uni-trier.de/lectures/algeo/slides/
// https://www.youtube.com/watch?v=3G5d8ob_Lfo&t=15s

// Constants and data for spatial hash (hash variable must be of array type)

var spatialHash=[];
const gridSize=100;
const gridMaxX=800;
const gridMaxY=800;

// Input points from https://codeforces.com/blog/entry/85638
var pointlist=[
    {x:266,y:468},{x:356,y:297},{x:209,y:130},{x:442,y:112},{x:700,y:75},{x:81,y:344},{x:617,y:260},{x:75,y:558},{x:473,y:468},
    {x:723,y:458},{x:570,y:622},{x:617,y:618},{x:280,y:110},{x:748,y:170},{x:694,y:175},{x:533,y:791},{x:791,y:689},{x:414,y:565},
    {x:436,y:183},{x:238,y:322},{x:283,y:619},{x:529,y:33},{x:285,y:66},{x:322,y:285},{x:559,y:101},{x:401,y:656},{x:107,y:568},
    {x:352,y:181},{x:77,y:696},{x:715,y:657},{x:201,y:78}
];
// Test count for 31 coordinate pairs is 4714

// Intersection of pointlist polygon and ray for voronoi diagram
function intersectPolygon(pointlist,r1,r2,q)
{
    // Return array
    var retarr=[];
    var foundarr=[];
    for(var i=0;i<pointlist.length;i++){
        var p1=pointlist[i];
        var p2=pointlist[(i+1)%pointlist.length];
        col=intersect(p1,p2,r1,r2);

        // If an intersection is found we store the point and the position of the intersection
        if(col!=false){
            foundarr.push({x:col.x,y:col.y,pos:i});
            //c.beginPath();
            //c.arc(col.x,col.y,5,0,Math.PI*2.0);
            //c.fill();
        }
    }
    
    if(foundarr.length==2){
        // Make first array of points before intersection
        var newarr=[];
        for(var i=0;i<=foundarr[0].pos;i++){
            newarr.push(pointlist[i]);
        }
        newarr.push({x:foundarr[0].x,y:foundarr[0].y});
        newarr.push({x:foundarr[1].x,y:foundarr[1].y});
        for(var i=foundarr[1].pos+1;i<pointlist.length;i++){
            newarr.push(pointlist[i]);
        }

        // Check if point is inside array
        if(insidePoly(newarr,q)){
            return newarr;
        }

        // Make alternate array
        var otherarr=[];
        otherarr.push({x:foundarr[0].x,y:foundarr[0].y});
        for(var i=foundarr[0].pos+1;i<=foundarr[1].pos;i++){
            otherarr.push(pointlist[i]);
        }
        otherarr.push({x:foundarr[1].x,y:foundarr[1].y});
        return otherarr;

    }else{
        return null;
    }
}

function zetup()
{
    // Initialize spatial hash
    clearHash(gridSize,gridMaxX,gridMaxY)
    var i=0;
    for(point of pointlist){
        point.id=i++;
        storeHash(point.x,point.y,point);
    }

/*
    for(var y=0;y<8;y++){
        for(var x=0;x<8;x++){
            var cnt=countHash(x,y);
        }
    }
*/

    collateHash(6,1);

		var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");
    updatestate();
}

const maxExtent=10000;
function processPoints(pointlist,treshold)
{
    // We first find extents including offsets
    var x1=maxExtent;
    var x2=-maxExtent;
    var y1=maxExtent;
    var y2=-maxExtent;
    for(point of pointlist){
        x1=Math.min(x1,point.x-treshold);
        x2=Math.max(x2,point.x+treshold);
        y1=Math.min(y1,point.y-treshold);
        y2=Math.max(y2,point.y+treshold);    
    }
    if(x1<gridSize) x1=0;
    if(x2>(gridMaxX-gridSize)) x2=gridMaxX;
    if(y1<gridSize) y1=0;
    if(y2>(gridMaxY-gridSize)) y2=gridMaxY;


    var polypoints=[{x:x1,y:y1},{x:x2,y:y1},{x:x2,y:y2},{x:x1,y:y2}];

    // For each point except for first
    for(var i=1;i<pointlist.length;i++){
        p1={x:(pointlist[0].x+pointlist[i].x)*0.5,y:(pointlist[0].y+pointlist[i].y)*0.5};
        p2={x:p1.x-(pointlist[0].y-pointlist[i].y),y:p1.y+(pointlist[0].x-pointlist[i].x)};
        var intersected=intersectPolygon(polypoints,p1,p2,pointlist[0]);
        if(intersected!=null) polypoints=intersected;
        // drawLine(pointlist[0].x,pointlist[0].y,pointlist[i].x,pointlist[i].y,1.5,"#606");
    }

    return polypoints;
}

function updatestate()
{
    var str="";
    for(var i=0;i<20;i++){
        str+="{x:"+Math.round(Math.random()*800)+",y:"+Math.round(Math.random()*800)+"},";
    }
    // console.log(str);

/*
    for(var i=0;i<520;i++){
        pointlist.push({x:Math.floor(Math.random()*gridMaxX),y:Math.floor(Math.random()*gridMaxY)});
    }
*/
    var voronoipolygons=[];
 
    for(var i=0;i<pointlist.length;i++){
        var pp=pointlist.pop();
        pointlist.unshift(pp);
        voronoipolygons.push(processPoints(pointlist,20));
    }

    for(polygon of voronoipolygons){
        drawPolygon(polygon,randomColor(),true);
    }

   // Draw points and hashgrid
    drawPointList(pointlist,"#25e","#000",16,0.5);
    drawGrid("#fff",0.5);

    console.log(testcnt);
}		
			
		</script>
</head>
<body onload="zetup();">
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas> 
  <button onclick="generate();">Render</button>
</body>