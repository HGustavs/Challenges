<html>
	<head>
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Diamond cuts with 3d camera and minimal code

// Diamond Geometry
// https://www.fascinatingdiamonds.com/blog/what-your-diamond-shape-says-about-you/
// https://cdnb.artstation.com/p/marketplace/presentation_assets/001/088/299/large/file.jpg?1627566775
// https://en.wikipedia.org/wiki/Brilliant_(diamond_cut)

// Construct view matrix / projection matrix
// https://www.3dgep.com/understanding-the-view-matrix/
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#perspective_projection_matrix

var c;
var arrpnt=[];
var delay=30;		

var xmax=1430;
var ymax=780;

var mx,my,mb;

function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");

		// setTimeout(drawHead,delay);
		drawHead();
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * Generates a minimum of new data and utilizes matrix components directly
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
//----------------------------------------------------------------------------------

function mulMP(matrix, point, resultpoint)
{
    // Multiply the point against each part of the n-th column, then add together
    resultpoint[0] = (point[0] * matrix[ 0]) + (point[1] * matrix[ 4]) + (point[2] * matrix[ 8]) + (point[3] * matrix[12]);
    resultpoint[1] = (point[0] * matrix[ 1]) + (point[1] * matrix[ 5]) + (point[2] * matrix[ 9]) + (point[3] * matrix[13]);
    resultpoint[2] = (point[0] * matrix[ 2]) + (point[1] * matrix[ 6]) + (point[2] * matrix[10]) + (point[3] * matrix[14]);
    resultpoint[3] = (point[0] * matrix[ 3]) + (point[1] * matrix[ 7]) + (point[2] * matrix[11]) + (point[3] * matrix[15]);
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * Generates a minimum of new data and utilizes matrix components directly
// https://stackoverflow.com/questions/9298558/how-to-multiply-two-4x4-matrices-written-as-two-16-element-arrays
//------------------------------------------------------------------------------

function mulMM(matrixA, matrixB, resultmatrix)
{
    for(var row=0; row<16; row+=4){
      for(var col=0; col<4; col++){
          resultingArray[row+col] = 0;
          for (var j=0, bCount=0; j<4; j++, bCount+=4){
              result[row+col] += matrixA[row+col%4] * matrixB[bCount+col%4];
          }
      }
    }
}

// ------------========#### Perspective Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function perspectiveM =  (fOVInRad, aspectRatio, near, far) 
{
    const f = 1.0 / Math.tan(fOVInRad / 2);
    const rangeInv = 1 / (near - far);

    return [
      f / aspectRatio, 0,                          0,   0,
      0,               f,                          0,   0,
      0,               0,    (near + far) * rangeInv,  -1,
      0,               0,  near * far * rangeInv * 2,   0
    ];
}

// ------------========#### Camera Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function LookAtMat(eye, target, up )
{
    let zaxis = normalizeV(subV(eye,target));    
    let xaxis = normalizeV(crossV(up, zaxis));
    let yaxis = crossV(zaxis, xaxis);     

    // Create a 4x4 view matrix from the right, up, forward and eye position vectors
    let viewMatrix = [
        xaxis[0],  yaxis[0], zaxis[0], 0,
        xaxis[1],  yaxis[1], zaxis[1], 0,
        xaxis[2],  yaxis[2], zaxis[2], 0,
        -dot( xaxis, eye ), -dot( yaxis, eye ), -dot( zaxis, eye ), 1
    ];
    
    return viewMatrix;
}

// ------------========#### 3Vector Normalize ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function normalizeV(vecA)
{
  var norm=[0,0,0,0];
  var len=Math.sqrt((vecA[0]*vecA[0])+(vecA[1]*vecA[1])+(vecA[2]*vecA[2]));

  norm[0]=vecA[0]/len;
  norm[1]=vecA[1]/len;
  norm[2]=vecA[2]/len;

  return norm;
}

// ------------========#### 3Vector Subtract ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function subV(vecA,vecB)
{
  var sub=[0,0,0,0];

  sub[0]=vecA[0]-vecB[0];
  sub[1]=vecA[1]-vecB[1];
  sub[2]=vecA[2]-vecB[2];
  return sub;
}

// ------------========#### 3Vector Dot Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function dotV(vecA,vecB)
{
  var sum=0
  sum+=vecA[0]*vecB[0];
  sum+=vecA[1]*vecB[1];
  sum+=vecA[2]*vecB[2];
  return sum;
}

// ------------========#### 3Vector Cross Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function crossV(vecA,vecB)
{
  var cross=[0,0,0,0];
  cross[0] = vecA[1] * vecB[2] - vecA[2] * vecB[1];
  cross[1] = vecA[2] * vecB[0] - vecA[0] * vecB[2];
  cross[2] = vecA[0] * vecB[1] - vecA[1] * vecB[0];
  return cross;
}

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
    var point=[100,200,300,0];
    var unitymatrix=
    [1, 0, 0, 0,
     0, 1, 0, 0,
     0, 0, 1, 0,
     0, 0, 0, 1]
    var output=[0,0,0,0];

    multiplyMatrixAndPoint(unitymatrix,point,output);
    console.log(output);

    c.globalAlpha=1.0;
		c.clearRect(0,0,xmax,ymax);
	
		c.fillStyle = "RGB(0,59,85)";	
		c.strokeStyle="#bbb";

		var polygons=[];
		var vertices=[];
	
		// Generate first set of vertices
    for(var v=0;v<6.28;v+=(6.28/8)){
        vertices.push({x:Math.sin(v)*100,y:Math.cos(v)*100});
    }
    for(var v=(6.28/16);v<6.28+((6.28/16));v+=(6.28/8)){
        vertices.push({x:Math.sin(v)*120,y:Math.cos(v)*120});
    }
    for(var v=0;v<6.28;v+=(6.28/16)){
        vertices.push({x:Math.sin(v)*150,y:Math.cos(v)*150});
    }
    // Generate Octagons
    polygons.push({edges:[0,1,2,3,4,5,6,7]});
    
    // Generate Triangles
    for(var i=0;i<8;i++){
        polygons.push({edges:[i,(i+1)%8,i+8]});
    }
    for(var i=0;i<16;i++){
        polygons.push({edges:[i+16,((i+17)%16)+16,Math.floor((i+16)/2)]});
    }    
    // Generate Quads
    for(var i=1;i<8;i++){
        polygons.push({edges:[i,(i+7),((i+8)*2),i+8]});
    }
    polygons.push({edges:[0,15,16,8]});
   

    c.font = "18px Arial Narrow";
    c.textBaseline = 'middle';
    for(var i=0;i<vertices.length;i++){
        var vert=vertices[i];
        c.beginPath();
        c.arc(400+vert.x, 400+vert.y, 5, 0, 2 * Math.PI);
        c.fill();

        c.fillText(i, 400+vert.x+8, 400+vert.y);     
    }

    // Draw polygons
    for(var i=0;i<polygons.length;i++){
      edges=polygons[i].edges;
      if(edges.length>0){
        c.beginPath();
        for(var j=0;j<edges.length;j++){
            if(j==0){
              c.moveTo(400+vertices[edges[edges.length-1]].x,400+vertices[edges[edges.length-1]].y);
            }
            c.lineTo(400+vertices[edges[j]].x,400+vertices[edges[j]].y);
        }
        c.fill();
        c.stroke();
      }
    }

}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>