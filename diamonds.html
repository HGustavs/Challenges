<html>
	<head>
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Diamond cuts with 3d camera and minimal code

// Diamond Geometry
// https://www.fascinatingdiamonds.com/blog/what-your-diamond-shape-says-about-you/
// https://cdnb.artstation.com/p/marketplace/presentation_assets/001/088/299/large/file.jpg?1627566775
// https://en.wikipedia.org/wiki/Brilliant_(diamond_cut)

// Construct view matrix / projection matrix
// https://www.3dgep.com/understanding-the-view-matrix/
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#perspective_projection_matrix

var c;
var arrpnt=[];
var delay=30;		

var xmax=1430;
var ymax=780;

var mx,my,mb;

function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");

		// setTimeout(drawHead,delay);
		drawHead();
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * Generates a minimum of new data and utilizes matrix components directly
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
//----------------------------------------------------------------------------------

function mulMP(matrix, point)
{
    // Multiply the point against each part of the n-th column, then add together
    let resultpoint=[0,0,0,0];
    resultpoint[0] = (point[0] * matrix[ 0]) + (point[1] * matrix[ 4]) + (point[2] * matrix[ 8]) + (point[3] * matrix[12]);
    resultpoint[1] = (point[0] * matrix[ 1]) + (point[1] * matrix[ 5]) + (point[2] * matrix[ 9]) + (point[3] * matrix[13]);
    resultpoint[2] = (point[0] * matrix[ 2]) + (point[1] * matrix[ 6]) + (point[2] * matrix[10]) + (point[3] * matrix[14]);
    resultpoint[3] = (point[0] * matrix[ 3]) + (point[1] * matrix[ 7]) + (point[2] * matrix[11]) + (point[3] * matrix[15]);
    
    return resultpoint;
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * Generates a minimum of new data and utilizes matrix components directly
// https://stackoverflow.com/questions/9298558/how-to-multiply-two-4x4-matrices-written-as-two-16-element-arrays
//------------------------------------------------------------------------------

function mulMM(matrixA, matrixB, resultmatrix)
{
    for(var row=0; row<16; row+=4){
      for(var col=0; col<4; col++){
          resultmatrix[row+col] = 0;
          for (var j=0, bCount=0; j<4; j++, bCount+=4){
              resultmatrix[row+col] += matrixA[row+col%4] * matrixB[bCount+col%4];
          }
      }
    }
}

// ------------========#### Perspective Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function perspectiveM(fOVInRad, aspectRatio, near, far) 
{
    const f = 1.0 / Math.tan(fOVInRad/2);
    const rangeInv = 1 / (near - far);

  return [
    f / aspectRatio, 0,                          0,   0,
    0,               f,                          0,   0,
    0,               0,    (near + far) * rangeInv,  -1,
    0,               0,  near * far * rangeInv * 2,   0
  ];    
}

// ------------========#### Camera Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function LookAtMat(eye, target, up )
{
    let zaxis = normalizeV(subV(eye,target));    
    let xaxis = normalizeV(crossV(up, zaxis));
    let yaxis = crossV(zaxis, xaxis);     

    // Create a 4x4 view matrix from the right, up, forward and eye position vectors
    let viewMatrix = [
        xaxis[0],  yaxis[0], zaxis[0], 0,
        xaxis[1],  yaxis[1], zaxis[1], 0,
        xaxis[2],  yaxis[2], zaxis[2], 0,
        -dotV( xaxis, eye ), -dotV( yaxis, eye ), -dotV( zaxis, eye ), 1
    ];
    
    return viewMatrix;
}

// ------------========#### 3Vector Normalize ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function normalizeV(vecA)
{
  var norm=[0,0,0,0];
  var len=Math.sqrt((vecA[0]*vecA[0])+(vecA[1]*vecA[1])+(vecA[2]*vecA[2]));

  norm[0]=vecA[0]/len;
  norm[1]=vecA[1]/len;
  norm[2]=vecA[2]/len;

  return norm;
}

// ------------========#### 3Vector Subtract ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function subV(vecA,vecB)
{
  var sub=[0,0,0,0];

  sub[0]=vecA[0]-vecB[0];
  sub[1]=vecA[1]-vecB[1];
  sub[2]=vecA[2]-vecB[2];
  return sub;
}

// ------------========#### 3Vector Dot Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function dotV(vecA,vecB)
{
  var sum=0
  sum+=vecA[0]*vecB[0];
  sum+=vecA[1]*vecB[1];
  sum+=vecA[2]*vecB[2];
  return sum;
}

// ------------========#### 3Vector Cross Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function crossV(vecA,vecB)
{
  var cross=[0,0,0,0];
  cross[0] = vecA[1] * vecB[2] - vecA[2] * vecB[1];
  cross[1] = vecA[2] * vecB[0] - vecA[0] * vecB[2];
  cross[2] = vecA[0] * vecB[1] - vecA[1] * vecB[0];
  return cross;
}

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------

var camerap=0;
var objp=0;

function drawHead()
{
    console.clear();
    camerap=camerap-6;
    objp-=0;

    c.globalAlpha=1.0;
		c.clearRect(0,0,xmax,ymax);
	
		c.fillStyle = "RGB(0,59,85)";	
		c.strokeStyle="#bbb";

		var polygons=[];
		var vertices=[];

		// Generate first set of vertices
    for(var v=0;v<6.28;v+=(6.28/8)){
        vertices.push([Math.sin(v)*80,-80,objp+(Math.cos(v)*80),1.0]);
    }
    for(var v=(6.28/16);v<6.28+((6.28/16));v+=(6.28/8)){
        vertices.push([Math.sin(v)*120,-70,objp+(Math.cos(v)*120),1.0]);
    }
    for(var v=0;v<6.28;v+=(6.28/16)){
        vertices.push([Math.sin(v)*150,-30,objp+(Math.cos(v)*150),1.0]);
    }

    let identityMatrix = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 0
    ];

    // temp matrix
    var vpMatrix=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

    // Generate view matrix for a camera at 0,0,-200 looking at 0,0,0 with an up-vector poinint up in Y
    var viewMatrix=LookAtMat([0,camerap/2,camerap],[0,0,0],[0,1,0]);

    // fov of 30 degrees, aspect of 1, near 20 and far 500
    var perspMatrix=perspectiveM(0.7, 1, 20, 500);     

    // Multiply viewMatrix and perspMatrix store in vpMatrix
    mulMM(viewMatrix,perspMatrix,vpMatrix);

    c.fillStyle="#55f";
 
    for(var i=0;i<vertices.length;i++){
        var resP=mulMP(viewMatrix,vertices[i]);
        var resQ=mulMP(perspMatrix,resP);

        // Perspective division (https://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/graphics_6_1_eng_web.html#1)
        vertices[i][0]=resQ[0]/resQ[3];
        vertices[i][1]=resQ[1]/resQ[3];
        vertices[i][2]=resQ[2]/resQ[3];

        if(i<10){
            // console.log(resQ);
        }

        if(resQ[3]>0){
            c.fillStyle="#f00";
            c.beginPath();
            c.arc(400+(resQ[0]*100), 400+(resQ[1]*100), 5, 0, 2 * Math.PI);
            c.fill();        

        }
    }

    c.strokeStyle="#080";

    c.beginPath();
    c.rect(300,300,200,200);
    c.stroke();
    //console.log(vertices);

	  // Generate Octagons
    polygons.push({edges:[0,1,2,3,4,5,6,7]});
    
    // Generate Triangles
    for(var i=0;i<8;i++){
        polygons.push({edges:[i,(i+1)%8,i+8]});
    }
    for(var i=0;i<16;i++){
        polygons.push({edges:[i+16,((i+17)%16)+16,Math.floor((i+16)/2)]});
    }    
    // Generate Quads
    for(var i=1;i<8;i++){
        polygons.push({edges:[i,(i+7),((i+8)*2),i+8]});
    }
    polygons.push({edges:[0,15,16,8]});
   

    c.font = "18px Arial Narrow";
    c.textBaseline = 'middle';
    for(var i=0;i<vertices.length;i++){
        var vert=vertices[i];
        c.beginPath();
        c.arc(400+vert.x, 400+vert.y, 5, 0, 2 * Math.PI);
        c.fill();

        c.fillText(i, 400+vert.x+8, 400+vert.y);     
    }

    // Draw polygons
    for(var i=0;i<polygons.length;i++){
      edges=polygons[i].edges;
      if(edges.length>0){
        c.beginPath();
        for(var j=0;j<edges.length;j++){
            if(j==0){
              c.moveTo(400+(vertices[edges[edges.length-1]][0]*100),400+(vertices[edges[edges.length-1]][1]*100));
            }
            c.lineTo(400+(vertices[edges[j]][0]*100),400+(vertices[edges[j]][1]*100));
        }
        //c.fill();
        c.stroke();
      }
    }

    setTimeout(drawHead,100);

}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>