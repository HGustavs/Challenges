<html>
	<head>
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Diamond cuts with 3d camera and minimal code

// Diamond Geometry
// https://www.fascinatingdiamonds.com/blog/what-your-diamond-shape-says-about-you/
// https://cdnb.artstation.com/p/marketplace/presentation_assets/001/088/299/large/file.jpg?1627566775
// https://en.wikipedia.org/wiki/Brilliant_(diamond_cut)

// Construct view matrix / projection matrix
// https://www.3dgep.com/understanding-the-view-matrix/
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#perspective_projection_matrix

var c;
var arrpnt=[];
var delay=30;		

var xmax=1430;
var ymax=780;

var mx=0,my=0,mb=0;

function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");

		// setTimeout(drawHead,delay);
		drawHead();
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * Generates a minimum of new data and utilizes matrix components directly
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
//----------------------------------------------------------------------------------

function mulMP(matrix, point)
{
    // Multiply the point against each part of the n-th column, then add together
    let resultpoint=[0,0,0,0];
    resultpoint[0] = (point[0] * matrix[ 0]) + (point[1] * matrix[ 4]) + (point[2] * matrix[ 8]) + (point[3] * matrix[12]);
    resultpoint[1] = (point[0] * matrix[ 1]) + (point[1] * matrix[ 5]) + (point[2] * matrix[ 9]) + (point[3] * matrix[13]);
    resultpoint[2] = (point[0] * matrix[ 2]) + (point[1] * matrix[ 6]) + (point[2] * matrix[10]) + (point[3] * matrix[14]);
    resultpoint[3] = (point[0] * matrix[ 3]) + (point[1] * matrix[ 7]) + (point[2] * matrix[11]) + (point[3] * matrix[15]);
    
    return resultpoint;
}

// ------------========#### Matrix point multiplication ####========------------
// * Uses a 16 point matrix for the sake of simplicity
// * static inline void Matrix4x4MultiplyBy4x4
// * Generates a minimum of new data and utilizes matrix components directly
// https://stackoverflow.com/questions/1674005/fast-4x4-matrix-multiplication-in-c
//------------------------------------------------------------------------------

function mulMM(src1, src2, dest)
{
    var dest=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    dest[0+0] = src1[0+0] * src2[0+0] + src1[0+1] * src2[4+0] + src1[0+2] * src2[8+0] + src1[0+3] * src2[12+0]; 
    dest[0+1] = src1[0+0] * src2[0+1] + src1[0+1] * src2[4+1] + src1[0+2] * src2[8+1] + src1[0+3] * src2[12+1]; 
    dest[0+2] = src1[0+0] * src2[0+2] + src1[0+1] * src2[4+2] + src1[0+2] * src2[8+2] + src1[0+3] * src2[12+2]; 
    dest[0+3] = src1[0+0] * src2[0+3] + src1[0+1] * src2[4+3] + src1[0+2] * src2[8+3] + src1[0+3] * src2[12+3]; 
    dest[4+0] = src1[4+0] * src2[0+0] + src1[4+1] * src2[4+0] + src1[4+2] * src2[8+0] + src1[4+3] * src2[12+0]; 
    dest[4+1] = src1[4+0] * src2[0+1] + src1[4+1] * src2[4+1] + src1[4+2] * src2[8+1] + src1[4+3] * src2[12+1]; 
    dest[4+2] = src1[4+0] * src2[0+2] + src1[4+1] * src2[4+2] + src1[4+2] * src2[8+2] + src1[4+3] * src2[12+2]; 
    dest[4+3] = src1[4+0] * src2[0+3] + src1[4+1] * src2[4+3] + src1[4+2] * src2[8+3] + src1[4+3] * src2[12+3]; 
    dest[8+0] = src1[8+0] * src2[0+0] + src1[8+1] * src2[4+0] + src1[8+2] * src2[8+0] + src1[8+3] * src2[12+0]; 
    dest[8+1] = src1[8+0] * src2[0+1] + src1[8+1] * src2[4+1] + src1[8+2] * src2[8+1] + src1[8+3] * src2[12+1]; 
    dest[8+2] = src1[8+0] * src2[0+2] + src1[8+1] * src2[4+2] + src1[8+2] * src2[8+2] + src1[8+3] * src2[12+2]; 
    dest[8+3] = src1[8+0] * src2[0+3] + src1[8+1] * src2[4+3] + src1[8+2] * src2[8+3] + src1[8+3] * src2[12+3]; 
    dest[12+0] = src1[12+0] * src2[0+0] + src1[12+1] * src2[4+0] + src1[12+2] * src2[8+0] + src1[12+3] * src2[12+0]; 
    dest[12+1] = src1[12+0] * src2[0+1] + src1[12+1] * src2[4+1] + src1[12+2] * src2[8+1] + src1[12+3] * src2[12+1]; 
    dest[12+2] = src1[12+0] * src2[0+2] + src1[12+1] * src2[4+2] + src1[12+2] * src2[8+2] + src1[12+3] * src2[12+2]; 
    dest[12+3] = src1[12+0] * src2[0+3] + src1[12+1] * src2[4+3] + src1[12+2] * src2[8+3] + src1[12+3] * src2[12+3]; 
    return dest;
}

// ------------========#### Perspective Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function perspectiveM(fOVInRad, aspectRatio, near, far) 
{
    const f = 1.0 / Math.tan(fOVInRad/2);
    const rangeInv = 1 / (near - far);

  return [
    f / aspectRatio, 0,                          0,   0,
    0,               f,                          0,   0,
    0,               0,    (near + far) * rangeInv,  -1,
    0,               0,  near * far * rangeInv * 2,   0
  ];    
}

// ------------========#### Camera Matrix Generation ####========------------
// * Generates 4x4  Matrix
//----------------------------------------------------------------------

function LookAtMat(eye, target, up )
{
    let zaxis = normalizeV(subV(eye,target));    
    let xaxis = normalizeV(crossV(up, zaxis));
    let yaxis = crossV(zaxis, xaxis);     

    // Create a 4x4 view matrix from the right, up, forward and eye position vectors
    let viewMatrix = [
        xaxis[0],  yaxis[0], zaxis[0], 0,
        xaxis[1],  yaxis[1], zaxis[1], 0,
        xaxis[2],  yaxis[2], zaxis[2], 0,
        -dotV( xaxis, eye ), -dotV( yaxis, eye ), -dotV( zaxis, eye ), 1
    ];
    
    return viewMatrix;
}

// ------------========#### 3Vector Normalize ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function normalizeV(vecA)
{
  var norm=[0,0,0,0];
  var len=Math.sqrt((vecA[0]*vecA[0])+(vecA[1]*vecA[1])+(vecA[2]*vecA[2]));

  norm[0]=vecA[0]/len;
  norm[1]=vecA[1]/len;
  norm[2]=vecA[2]/len;

  return norm;
}

// ------------========#### 3Vector Subtract ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function subV(vecA,vecB)
{
  var sub=[0,0,0,0];

  sub[0]=vecA[0]-vecB[0];
  sub[1]=vecA[1]-vecB[1];
  sub[2]=vecA[2]-vecB[2];
  return sub;
}

// ------------========#### 3Vector Dot Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function dotV(vecA,vecB)
{
  var sum=0
  sum+=vecA[0]*vecB[0];
  sum+=vecA[1]*vecB[1];
  sum+=vecA[2]*vecB[2];
  return sum;
}

// ------------========#### 3Vector Cross Product ####========------------
// * Uses 3 elements from vectors 
//----------------------------------------------------------------------

function crossV(vecA,vecB)
{
  var cross=[0,0,0,0];
  cross[0] = vecA[1] * vecB[2] - vecA[2] * vecB[1];
  cross[1] = vecA[2] * vecB[0] - vecA[0] * vecB[2];
  cross[2] = vecA[0] * vecB[1] - vecA[1] * vecB[0];
  return cross;
}

// ------------========#### Triangle Surface Normal ####========------------
// * Uses 3 arbitrary points
//----------------------------------------------------------------------
// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
/*
Begin Function CalculateSurfaceNormal (Input Triangle) Returns Vector

	Set Vector U to (Triangle.p2 minus Triangle.p1)
	Set Vector V to (Triangle.p3 minus Triangle.p1)

	Set Normal.x to (multiply U.y by V.z) minus (multiply U.z by V.y)
	Set Normal.y to (multiply U.z by V.x) minus (multiply U.x by V.z)
	Set Normal.z to (multiply U.x by V.y) minus (multiply U.y by V.x)

	Returning Normal

End Function
*/

/*
          // Culling
					// Compute normal for backface culling
					normal=((p3x - p1x)*(p3y - p2y)) - ((p3y - p1y)* (p3x - p2x));
					
					if(normal<0){
							light=(-normal/16000);
					}else{
							light=0;
					}

*/

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------

var camerap=0;
var objp=0;

function drawHead()
{
    vx=(mx/1600)*2*6.28;

    console.clear();
    camerap=camerap-6;
    objp-=0;

    c.globalAlpha=1.0;
		c.clearRect(0,0,xmax,ymax);
	
		c.fillStyle = "RGB(0,59,85)";	
		c.strokeStyle="#bbb";

		var polygons=[];
		var vertices=[];

		// Generate first set of vertices
    for(var v=0;v<6.28;v+=(6.28/8)){
        vertices.push([Math.sin(v)*80,-80,objp+(Math.cos(v)*80),1.0]);
    }
    for(var v=(6.28/16);v<6.28+((6.28/16));v+=(6.28/8)){
        vertices.push([Math.sin(v)*120,-70,objp+(Math.cos(v)*120),1.0]);
    }
    for(var v=0;v<6.28;v+=(6.28/16)){
        vertices.push([Math.sin(v)*150,-30,objp+(Math.cos(v)*150),1.0]);
    }
    for(var v=(6.28/16);v<6.28+(6.28/16);v+=(6.28/8)){
        vertices.push([Math.sin(v)*100,20,objp+(Math.cos(v)*100),1.0]);
    }
    vertices.push([0,100,0,1.0]);    

    c.fillStyle="#55f"; 
    c.strokeStyle="#080";       
    c.font = "18px Arial Narrow";
    c.textBaseline = 'middle';

    for(var i=16;i<vertices.length;i++){
        var vert=vertices[i];

        c.beginPath();
        c.arc(800+vert[0], 200+vert[2], 5, 0, 2 * Math.PI);
        c.fill();

        c.fillText(i, 800+vert[0]+8, 200+vert[2]);     
    }

    c.beginPath();
   // c.rect(300,300,200,200);
    c.stroke();

	  // Generate Octagons
    polygons.push({edges:[0,1,2,3,4,5,6,7]});
    
    // Generate Triangles
    for(var i=0;i<8;i++){
        polygons.push({edges:[(i+1)%8,i,i+8]});
    }
    for(var i=0;i<16;i++){
        polygons.push({edges:[i+16,((i+17)%16)+16,Math.floor((i+16)/2)]});
    }    
    for(var i=0;i<16;i++){
        polygons.push({edges:[16+((i+1)%16),i+16,32+Math.floor((i/2))]});
    } 
    // Generate Quads
    for(var i=1;i<8;i++){
        // polygons.push({edges:[i,(i+7),((i+8)*2),i+8]});
        polygons.push({edges:[i,(i+7),i+8]});
        polygons.push({edges:[i+8,(i+7),((i+8)*2)]});        
    }
    //polygons.push({edges:[0,15,16,8]});
    polygons.push({edges:[0,15,8]});
    polygons.push({edges:[8,15,16]});

    // Bottom triangles
    for(var i=0;i<8;i++){
        polygons.push({edges:[i+32,32+((i+1)%8),16+(((i+1)*2)%16)]});
        polygons.push({edges:[32+((i+1)%8),i+32,40]});
    }

    // Show flat polygons
    for(var i=0;i<polygons.length;i++){
        edges=polygons[i].edges;
        for(var j=0;j<edges.length;j++){
            c.beginPath();
            c.moveTo(800+(vertices[edges[j]][0]),200+(vertices[edges[j]][2]));
            c.lineTo(800+(vertices[edges[(j+1)%edges.length]][0]),200+(vertices[edges[(j+1)%edges.length]][2]));
            c.moveTo(800+(vertices[edges[j]][0]),600+(vertices[edges[j]][1]));
            c.lineTo(800+(vertices[edges[(j+1)%edges.length]][0]),600+(vertices[edges[(j+1)%edges.length]][1]));
            c.stroke();
        }
    }
  
    // Generate view matrix for a camera at 0,0,-200 looking at 0,0,0 with an up-vector poinint up in Y
    var viewMatrix=LookAtMat([400*Math.sin(vx),50,400*Math.cos(vx)],[0,0,0],[0,1,0]);

    // fov of 30 degrees, aspect of 1, near 20 and far 500
    var perspMatrix=perspectiveM(0.7, 1, 20, 500);     

    // Multiply viewMatrix and perspMatrix store in vpMatrix
    var vpMatrix=mulMM(viewMatrix,perspMatrix);

    for(var i=0;i<vertices.length;i++){
        // Multi-step matrix multiplication
        // var resP=mulMP(viewMatrix,vertices[i]);
        // var resQ=mulMP(perspMatrix,resP);
        var resQ=mulMP(vpMatrix,vertices[i]);

        // Perspective division (https://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/graphics_6_1_eng_web.html#1)
        vertices[i][0]=resQ[0]/resQ[3];
        vertices[i][1]=resQ[1]/resQ[3];
        vertices[i][2]=resQ[2]/resQ[3];

        if(resQ[3]>0){
            c.fillStyle="#f00";
            c.beginPath();
            c.arc(400+(resQ[0]*100), 400+(resQ[1]*100), 5, 0, 2 * Math.PI);
            c.fill();        

        }
    }    

    // Draw polygons
    for(var i=0;i<polygons.length;i++){
      edges=polygons[i].edges;
      if(edges.length>=3){
        // normal=((p3x - p1x)*(p3y - p2y)) - ((p3y - p1y)* (p3x - p2x));
        var normal=((vertices[edges[2]][0]-vertices[edges[0]][0])*(vertices[edges[2]][1]-vertices[edges[1]][1]))-
                   ((vertices[edges[2]][1]-vertices[edges[0]][1])*(vertices[edges[2]][0]-vertices[edges[1]][0]));
        if(normal>0){
            c.beginPath();
            for(var j=0;j<edges.length;j++){
                if(j==0){
                  c.moveTo(400+(vertices[edges[edges.length-1]][0]*100),400+(vertices[edges[edges.length-1]][1]*100));
                }
                c.lineTo(400+(vertices[edges[j]][0]*100),400+(vertices[edges[j]][1]*100));
            }
            c.fill();
            c.stroke();
        }
      }
    }

    window.requestAnimationFrame(drawHead);
//    setTimeout(drawHead,100);

}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.	
    
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1600 height=800 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>