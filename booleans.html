<html>
<head>
		<style>
				body {margin: 0; height: 100%; overflow: hidden}
		</style>
    <script src="helperFunction/canvasDraw.js"></script>
		<script>

        //        (\ /)
        //        (. .)           
        //       c(")(")     âˆ´ 
        // Raycast Shadows
        // Codetrain 
        // https://www.youtube.com/watch?v=TOEi6T2mtHo&t=16s
        // https://ncase.me/sight-and-light/
        // https://www.redblobgames.com/articles/visibility/
        // Rays toward each segment end point

        // We need spatial hash to only test cells near ray
        // https://stackoverflow.com/questions/24679963/precise-subpixel-line-drawing-algorithm-rasterization-algorithm
        // https://stackoverflow.com/questions/4381269/line-rasterisation-cover-all-pixels-regardless-of-line-gradient

				var c;
        var mx,my,md;

        // Avatar variables
        var xk=320;
        var yk=140;
        var xd=0;
        var yd=0;

        // Benchmarking
        var intersectcount=0;

//------------------------------------=======############==========----------------------------------------
//                                 Spatial Hash Global Variables and Constants
//------------------------------------=======############==========----------------------------------------
	        
var hash=[];
var found=[];
const gridsize=50;                          // Spatial hash grid size
const gridhalf=gridsize/2;
const cwidth=1800;
const cheight=1800;
const gridx=Math.ceil(cwidth/gridsize);
const gridy=Math.floor(cheight/gridsize);
const gridscale=1.0;

const rayang=0.025;
const raylen=2200;
const lengthenRay=1.0;
			
const showHits=true;
const showRays=true;
const showGrid=true;

// Segments, Floor Clip Polygons, Shadow Areas 
var segments=[
    {x1:5,y1:283,x2:186,y2:147,id:0},
    {x1:186,y1:147,x2:279,y2:373,id:1},
    {x1:279,y1:373,x2:342,y2:186,id:2},
    {x1:342,y1:186,x2:520,y2:318,id:3},
    {x1:520,y1:318,x2:562,y2:444,id:4},
    {x1:562,y1:444,x2:84,y2:505,id:5},
    {x1:84,y1:505,x2:5,y2:283,id:6}
];

var segmentsb=[
  {x1:56, y1:101, x2:170, y2:12, id:101},
  {x1:170, y1:12, x2:380, y2:8, id:102},
  {x1:380, y1:12, x2:493, y2:208, id:103},
  {x1:493, y1:208, x2:380, y2:307, id:104},
  {x1:380, y1:307, x2:181, y2:253, id:105},
  {x1:181, y1:253, x2:56, y2:101, id:106}  
];

// line intercect math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
// Determine the intersection point of two line segments
function intersect(x1,y1,x2,y2,x3,y3,x4,y4) {
  intersectcount++;
	
  // Check if none of the lines are of length 0
  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) return false;

  denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

  // Lines are parallel
  if (denominator === 0) return false;

  let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
  let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

  // is the intersection along the segments
  if (ua <= -0.001 || ua >= 0.999 || ub <= -0.001 || ub >= 0.999) return false;

  // Return a object with the x and y coordinates of the intersection
  let x = x1 + ua * (x2 - x1)
  let y = y1 + ua * (y2 - y1)
  
  return {x:x, y:y}
}

function mouseMove(e,t)
{
		var rect = e.target.getBoundingClientRect();
    mx = e.clientX - rect.left; //x position within the element.
    my = e.clientY - rect.top;  //y position within the element

    if (md){
        xk=mx*(1.0/gridscale);
        yk=my*(1.0/gridscale);
    }
 }

 function mouseDown(e)
 {
    md=true;
 }

function mouseUp(e)
{
  md=false;
}

function keydown(e)
{
		if(e.keyCode==37){
				xd=-1;
		}else if(e.keyCode==39){
				xd=1;
		}else if(e.keyCode==38){
				yd=-1;
		}else if(e.keyCode==40){
				yd=1;
		}
}

function keyup(e)
{
		if(e.keyCode==37||e.keyCode==39){
				xd=0;
		}else if(e.keyCode==38||e.keyCode==40){
				yd=0;
		}
}			

function setup()
{
		var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    /*
    // Serialize Segments
    var str="";
    for(segment of segments){
        str+=("\n{x1:"+Math.round(segment.x1)+",y1:"+Math.round(segment.y1)+",x2:"+Math.round(segment.x2)+",y2:"+Math.round(segment.y2)+",id:"+segment.id+"},");
    }
    alert(str);
	  */

		drawit();
}
							
function updatestate()
{
		xk+=xd;
		yk+=yd;
}

function visualizeHit(cxk,cyk,segment)
{
  if(cxk<0||cyk<0||cxk>=gridx||cyk>=gridy) return false;

  var index=(cyk*gridx)+cxk;
  if(hash[index]==null){
      hash[index]=[];
  }
  pushIfNotPresent(hash[index],segment);
}

function readHit(cxk,cyk,segment)
{
  if(cxk<0||cyk<0||cxk>=gridx||cyk>=gridy) return false;
  
  var index=(cyk*gridx)+cxk;
  if(hash[index]!=null){
      for(segment of hash[index]){
          pushIfNotPresent(found,segment);
      }
  }
  if(showHits) drawBox(cxk*gridsize,cyk*gridsize,gridsize,gridsize,0.1,"#46f");
}

// Ray / Segment Spatial Hashing Bresenham Algorithm
// Itemcall function is called for each 'pixel' and is passed X and Y coordinate
function hashLine(x1,y1,x2,y2,segment,itemcall)
{
    // drawLine(x1,y1,x2,y2,2.0,"#c42");

    var dx=x2-x1;
    var dy=y2-y1;

    if(Math.abs(dx)>=Math.abs(dy)){
        var k=dy/dx;
        var m=y1-(k*x1);

        // Take care of left running lines
        if(x2<x1){
          tmp=x1;
          x1=x2;
          x2=tmp;
        }

        var cnt=Math.ceil(x2/gridsize)-Math.floor(x1/gridsize)+1;
        var xk=Math.floor(x1/gridsize);
        var oldyt=Math.floor(((k*xk*gridsize)+m)/gridsize);
        var ret=0;        
        for(var i=0;i<cnt;i++){
            yk=(k*(xk*gridsize)+m);
            yt=Math.floor(yk/gridsize);
            if(oldyt==yt){
                itemcall(xk,yt,segment);
            }else{
                itemcall(xk,yt,segment);
                itemcall(xk-1,yt,segment);
            }
            oldyt=yt;
            xk++;
        }
    }else{
        var k=dx/dy;
        var m=x1-(k*y1);

        // Take care of left running lines
        if(y2<y1){
          tmp=y1;
          y1=y2;
          y2=tmp;
        }

        var cnt=Math.ceil(y2/gridsize)-Math.floor(y1/gridsize)+1;
        var yk=Math.floor(y1/gridsize);
        var oldxt=Math.floor(((k*yk*gridsize)+m)/gridsize);
        var ret=0;
        for(var i=0;i<cnt;i++){
            xk=(k*(yk*gridsize)+m);
            xt=Math.floor(xk/gridsize);
            if(oldxt==xt){
                itemcall(xt,yk,segment);
            }else{
                itemcall(xt,yk,segment);
                itemcall(xt,yk-1,segment);
            }
            if(ret>0) break;
            oldxt=xt;
            yk++;
        }        
    }
}

// -------------------==============########==============-------------------
// Update of Spatial Hash - Find Which Segments that Intersect with Spatial Hash Cells
// We must make sure that we do not add same value to list again (to avoid double tests).
// Sparse Array?

function pushIfNotPresent(list,item)
{
    for(inner of list){
        if(inner.id==item.id) return false;
    }
    list.push(item);
}

// Even odd rule
function inside(xk,yk,path)
{
    console.log(xk,yk);
    drawCross(xk,yk,8,3,"#5d3");

    // Collect segments with Y coordinate around coordinate
    var cnt=0;
    for(var segment of path){
        if(segment.y2>segment.y1&&yk<=segment.y2&&yk>=segment.y1){
            let dx=segment.x2-segment.x1;
            let dy=segment.y2-segment.y1;
            let k=dx/dy;
            let m=segment.x1-(k*segment.y1);
            if(xk>=(k*yk)+m) cnt++;
        }else if(segment.y2<segment.y1&&yk<=segment.y1&&yk>=segment.y2){
            let dx=segment.x1-segment.x2;
            let dy=segment.y1-segment.y2;
            let k=dx/dy;
            let m=segment.x2-(k*segment.y2);
            if(xk>=(k*yk)+m) cnt++;
        }
    }
    if(cnt%2==0) return false;
    return true;
}

function drawit()
{	
    c.font='10px Arial Narrow';
    c.textAlign='left';
    c.textBaseline='middle';

		c.clearRect(0,0,900,900);
     
    c.save();
    c.scale(gridscale,gridscale);

    // Update hash...do we even need the hash for this?
    hash=[];
    for(segment of segments){
        hashLine(segment.x1,segment.y1,segment.x2,segment.y2,segment,visualizeHit);
    }

    if(showGrid) drawGrid();
		
    drawPath(segments,"#487");
    drawPath(segmentsb,"#874");

    var hitlist=[];

    for(segment of hitlist){
        drawLine(segment.x1,segment.y1,segment.x2,segment.y2,3,"#d62");
    }

    c.restore();

		// window.requestAnimationFrame(drawit);
}
			
		</script>
</head>
<body onload="setup();" onkeydown="keydown(event);" onkeyup="keyup(event);" onmousedown="mouseDown(event)" onmouseup="mouseUp(event)" onmousemove="mouseMove(event)">
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas>
	<svg style='border:1px dotted red;' height="900" width="900" id="mainsvg"></svg>
</body>
