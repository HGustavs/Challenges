<html>
    <head>
        <script src="helperFunction/seededrandomp.js"></script>
        <script>
        
        //        (\ /)
        //        (. .)           
        //       c(")(")     âˆ´ 

        // Steering behavior test suite with clustering algorithm
        // https://en.wikipedia.org/wiki/Boids
        // Codetrain Approach:
        // https://www.youtube.com/watch?v=mhjuuHl6qHM
        // separation: steer to avoid crowding local flockmates
        // alignment: steer towards the average heading of local flockmates
        // cohesion: steer to move towards the average position (center of mass) of local flockmates
        // 

        var ctx;
        
        const gridsize=50;        // Spatial hash grid size
        const gridhalf=gridsize/2;
        const cwidth=600;
        const cheight=600;
        const gridx=Math.floor(cwidth/gridsize);
        const gridy=Math.floor(cheight/gridsize);
        const maxSpeed=0.1;

        // PPS Constants
        const Alpha=Math.PI;        
        const Beta=Math.PI*(17/180);
        const Vel=0.57;
        const Rad=50;
        const RadQuad=Rad*Rad;

        // Display constants
        const TRIANGLE=1;
        const LINE=2;
        const showNet=false;
        const speedvis=LINE;

        // Primordial particle set
        var particles=[];
        var cells=[];        

        function addhash(cx,cy,incell){
            if(cx<0||cy<0||cx>=gridx||cy>=gridy) return false;

            var index=cx+(cy*gridx);
            if(cells[index]==null){
              cells[index]=[];
            }
            cells[index].push(incell);
        }

        function redraw()
        {
            ctx.clearRect(0,0,cwidth,cheight);
            // Take old position to make spatial hash

            // Clear cell array and update spatial hash
            cells=[];
            for(particle of particles){
                // Cell X, Cell Y and Hash
                let cellx=Math.floor(particle.x/gridsize);
                let celly=Math.floor(particle.y/gridsize);
                let incellx=particle.x-(cellx*gridsize);
                let incelly=particle.y-(celly*gridsize);
                particle.cellx=cellx;
                particle.celly=celly;
                particle.hash=cellx+(celly*gridx);

                // Add particle to nine closest cells
                addhash(cellx,celly-1,particle,0);
                addhash(cellx-1,celly-1,particle,1);
                addhash(cellx+1,celly-1,particle,1);
                addhash(cellx,celly,particle,0);
                addhash(cellx-1,celly,particle,1);
                addhash(cellx+1,celly,particle,1);
                addhash(cellx,celly+1,particle,0);
                addhash(cellx-1,celly+1,particle,1);
                addhash(cellx+1,celly+1,particle,1);               
            }
            
            // Iterate over cell in each cell
            for(particle of particles){
                var cell=cells[particle.hash];

                if(cell!=null){
                    // Alignment
                    var averageVx=0;
                    var averageVy=0;
                    var counter=1;
                    for(inner of cell){
                        var dx=inner.x-particle.x;
                        var dy=inner.y-particle.y;
                        var square=(dx*dx)+(dy*dy);

                        if(inner.id!=particle.id&&square<RadQuad){
                            counter++;
                            averageVx+=inner.vx;
                            averageVy+=inner.vy;

                            if(showNet){
                                ctx.strokeStyle="#ef4";                            
                                ctx.beginPath();
                                ctx.moveTo(particle.x,particle.y);
                                ctx.lineTo(inner.x,inner.y);
                                ctx.stroke();
                            }
                        }
                    }
                    particle.ax=averageVx/counter;
                    particle.ay=averageVy/counter;

                    // Cohesion?
                }
                
            }

            // For each particle update position according to angle
            for(particle of particles){                
                // Update particle position
                particle.vx+=particle.ax*0.01;
                particle.vy+=particle.ay*0.01;

                // Max speed limit 
                var vLen=Math.sqrt((particle.vx*particle.vx)+(particle.vy*particle.vy));
                particle.vx/=vLen;
                particle.vy/=vLen;
                particle.vx*=maxSpeed;
                particle.vy*=maxSpeed;

                particle.x+=particle.vx;
                particle.y+=particle.vy;
                if(particle.x<0) particle.x=cwidth;
                if(particle.x>cwidth) particle.x=0;
                if(particle.y<0) particle.y=cheight;
                if(particle.y>cheight) particle.y=0;         
            
//                if(particle.id==1) console.log(particle.x,particle.y,particle.vx,particle.vy,particle.ax,particle.ay);
            }


            // Draw particle
            for(particle of particles){
              
                ctx.fillStyle="#fff";
                //ctx.fillText(particle.nt,particle.x+10,particle.y);

                ctx.fillStyle="#888";                    
                ctx.beginPath();
                ctx.arc(particle.x,particle.y, 5,0, 2 * Math.PI);
                ctx.fill();                  

                if(speedvis==TRIANGLE){
                    ctx.strokeStyle="#191";
                    ctx.beginPath();
                    ctx.moveTo(particle.x+(particle.vx*5.0*(1/maxSpeed)),particle.y+(particle.vy*5.0*(1/maxSpeed)));
                    ctx.lineTo(particle.x+(particle.vy*5.0*(1/maxSpeed)),particle.y+(-particle.vx*5.0*(1/maxSpeed)));
                    ctx.lineTo(particle.x+(-particle.vy*5.0*(1/maxSpeed)),particle.y+(particle.vx*5.0*(1/maxSpeed))); 
                    ctx.closePath();                               
                    ctx.stroke();
                }else if(speedvis==LINE){
                    ctx.strokeStyle="#ef4";
                    ctx.beginPath();
                    ctx.moveTo(particle.x,particle.y);
                    ctx.lineTo(particle.x+(particle.vx*10.0*(1/maxSpeed)),particle.y+(particle.vy*10.0*(1/maxSpeed)));
                    ctx.stroke();
                }
            }

            window.requestAnimationFrame(redraw);
        }

        function startup()
        {
            var c = document.getElementById("canvasid");
            ctx = c.getContext("2d");

            // Create a random list of particles

            for(var i=0;i<100;i++){
                var ang=Math.random()*6.28;
                particles.push({id:i,x:300+(Math.random()*150),y:300+(Math.random()*150),vx:Math.sin(ang)*0.3,vy:Math.cos(ang)*0.3,color:0}); //Math.random()*6.28
            }
            
            redraw();
        }

    </script>
    </head>
    <body onload="startup();" style="background:#222;">
        <canvas id="canvasid" width="600" height="600" style="width:800px;height:800px;">
        </canvas>
        <!-- image-rendering:pixelated;  filter:blur(4px) -->
    </body>
</html>