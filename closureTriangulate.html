<html>
	<head>
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Closure and Triangulation
// Closure for small 

var c;

var xmax=1430;
var ymax=780;

var mx,my,mb;
		
// Color index start
var colstart=0;
		
const delay=30;
		
var points=[{x:100,y:100},{x:140,y:300},{x:120,y:260},{x:240,y:240},{x:240,y:290},{x:240,y:90},{x:40,y:170},{x:180,y:160},{x:280,y:110},{x:180,y:70},{x:150,y:150},{x:210,y:60}];
		
function drawCirc(x,y,r,fill)
{
	c.beginPath();
	c.arc(x, y, r, 0, 2 * 3.1415, false);
	if(fill==true){
			c.fill();	
	}else{
			c.stroke();	
	}

}
	
function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");
	
		var col=0;	

		setTimeout(drawHead,delay);
}
				
const radius=220;
var offs=0;

//----------------------------------------------------------------------------------
// inseg - Point Insdide Segment List Function
//----------------------------------------------------------------------------------

function inSegment(px, py, segmentlist)
{
  for(var i=0;i<segmentlist.length;i++){
        var segment=segmentlist[i];
        c.strokeStyle="#000";
        c.beginPath();
        c.moveTo(segment.x1,segment.y1);
        c.lineTo(segment.x2,segment.y2);
        c.stroke();
    }
}

//----------------------------------------------------------------------------------
// dist - Euclidian Distance Function
//----------------------------------------------------------------------------------

function dist(px, py , x, y)
{
    var dx = x - px;
    var dy = y - py;
    return Math.sqrt(dx * dx + dy * dy);
}

//----------------------------------------------------------------------------------
// distToSegment - Point to Line Segment Distance
//----------------------------------------------------------------------------------
// https://gist.github.com/mattdesl/47412d930dcd8cd765c871a65532ffac
// https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
// We find projection of point p onto the line. 
// It falls where t = [(p-v) . (w-v)] / |w-v|^2
// We clamp t from [0,1] to handle points outside the segment vw.		 

function distToSegment(px,py,x1,y2,x2,y2)
{
    var dx = x3 - x1;
    var dy = y2 - y1;
    var l2 = dx * dx + dy * dy;

    if (l2 == 0) return this.dist(px,py,x1,y1);

    var t = ((px - x1) * dx + (py - y1) * dy) / l2;
    t = Math.max(0, Math.min(1, t));

    return this.dist(px,py, x1 + t * dx, y1 + t * dy);
}

//----------------------------------------------------------------------------------
// dot - vector dot product
//----------------------------------------------------------------------------------
// https://www.mathsisfun.com/algebra/vectors-dot-product.html
// https://gamedev.stackexchange.com/questions/7131/how-can-i-calculate-the-angle-and-proper-turn-direction-between-two-2d-vectors
		 
function dot(ax,ay,bx,by)
{
    return (ax*bx)+(ay*by);
}

//----------------------------------------------------------------------------------
// cross - vector cross product
//----------------------------------------------------------------------------------

function cross(ax,ay,bx,by)
{
    // just calculate the z-component
    return ax*by - ay*bx;
}

//----------------------------------------------------------------------------------
// closure - make closure of point set and return line segment list
//----------------------------------------------------------------------------------

function closure(points)
{
    var segments=[];

    // Find minimum X
    var minx=1000;
    var pindex=null;
		for(var i=0;i<points.length;i++){
        if(points[i].x<minx){
            pindex=i;
            minx=points[i].x;
        }
        points[i].visited=false;
      }

    // Standard gift wrapping closure algorithm
    var lastindex=pindex;
    var lastpoint=points[pindex];
    var bestindex=0;
    var bestpoint=points[bestindex];
    var j=0;
    do{
        for(var i=0;i<points.length;i++){
            // Do not compare current point
            currpoint=points[i];
            if(i!=lastindex&&i!=bestindex&&currpoint.visited!=true){
                j++;
                // compare fresh deltas
                if(cross((lastpoint.x-bestpoint.x),(lastpoint.y-bestpoint.y),(lastpoint.x-currpoint.x),(lastpoint.y-currpoint.y))<0){
                    bestindex=i;
                    bestpoint=points[bestindex];
                }
            }

        }    

        bestpoint.visited=true;
        if(lastpoint.y>bestpoint.y){
            segments.push({x1:bestpoint.x,y1:bestpoint.y,x2:lastpoint.x,y2:lastpoint.y});
        }else{
          segments.push({x1:lastpoint.x,y1:lastpoint.y,x2:bestpoint.x,y2:bestpoint.y});
        }

        if(bestindex==pindex) break;
        lastindex=bestindex;
        lastpoint=points[bestindex];
        bestindex=lastindex+1;
        if(bestindex==points.length) bestindex=0;
        bestpoint=points[bestindex];        
    }while(true);

    return segments;
}

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
	
		c.clearRect(0,0,500,500);

/*
    c.strokeStyle="#4b3";
    c.beginPath();
    c.moveTo(points[pindex].x,0);
    c.lineTo(points[pindex].x,300);
    c.stroke();
*/

    c.fillStyle="#46d";
    
		for(var i=0;i<points.length;i++){
        var point=points[i];
        drawCirc(point.x,point.y,5,true);
    }

    var segments=closure(points);
    inSegment(140,100,segments);

		//window.requestAnimationFrame(drawHead);
		// setTimeout(drawHead,delay);	
}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>