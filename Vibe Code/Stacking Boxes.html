<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Verlet Physics Boxes</title>
  <style>
    canvas { background: #111; display: block; margin: auto; }
  </style>
</head>
<body>
<canvas id="canvas" width="400" height="600"></canvas>
<script>

/* 

I want to make a minimal physics engine in javascript that supports stacking of boxes that are falling from the top of the screen towards the bottom. The boxes should not fall through the bottom and sides of the screen. I suggest using particles and basing the engine on verlet physics.

* Particles + constraints to form rectangles (boxes)
* Gravity
* Ground and wall collisions
* Stacking support using constraint resolution
* Verlet integration

The boxes are not stacking and are intersection other boxes. Could sorting the boxes vertically help with the stacking behavior? 

Each box:
  *  Checks if its bottom particles are just above another box or the ground.
  *  If so, it snaps them into place by setting y equal to the surface below.


*/

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const GRAVITY = 0.5;
const FRICTION = 0.98;
const SUBSTEPS = 5;

class Particle {
  constructor(x, y) {
    this.x = this.oldx = x;
    this.y = this.oldy = y;
  }

  update() {
    let vx = (this.x - this.oldx) * FRICTION;
    let vy = (this.y - this.oldy) * FRICTION + GRAVITY;

    this.oldx = this.x;
    this.oldy = this.y;
    this.x += vx;
    this.y += vy;
  }

  constrain() {
    const r = 1;
    if (this.x < r) this.x = r;
    if (this.x > canvas.width - r) this.x = canvas.width - r;
    if (this.y > canvas.height - r) this.y = canvas.height - r;
  }
}

class Constraint {
  constructor(p1, p2, length = null) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = length ?? this.getLength();
  }

  getLength() {
    const dx = this.p2.x - this.p1.x;
    const dy = this.p2.y - this.p1.y;
    return Math.hypot(dx, dy);
  }

  resolve() {
    const dx = this.p2.x - this.p1.x;
    const dy = this.p2.y - this.p1.y;
    const dist = Math.hypot(dx, dy);
    const diff = (this.length - dist) / dist;

    const offsetX = dx * 0.5 * diff;
    const offsetY = dy * 0.5 * diff;

    this.p1.x -= offsetX;
    this.p1.y -= offsetY;
    this.p2.x += offsetX;
    this.p2.y += offsetY;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.p1.x, this.p1.y);
    ctx.lineTo(this.p2.x, this.p2.y);
    ctx.stroke();
  }
}

class Box {
  constructor(x, y, w, h) {
    this.w = w;
    this.h = h;

    const hw = w / 2, hh = h / 2;
    this.particles = [
      new Particle(x - hw, y - hh), // top-left
      new Particle(x + hw, y - hh), // top-right
      new Particle(x + hw, y + hh), // bottom-right
      new Particle(x - hw, y + hh), // bottom-left
    ];
    const [a, b, c, d] = this.particles;
    this.constraints = [
      new Constraint(a, b),
      new Constraint(b, c),
      new Constraint(c, d),
      new Constraint(d, a),
      new Constraint(a, c),
      new Constraint(b, d),
    ];
  }

  getBottomY() {
    return Math.max(this.particles[2].y, this.particles[3].y);
  }

  getTopY() {
    return Math.min(this.particles[0].y, this.particles[1].y);
  }

  getAABB() {
    const xs = this.particles.map(p => p.x);
    const ys = this.particles.map(p => p.y);
    return {
      minX: Math.min(...xs),
      maxX: Math.max(...xs),
      minY: Math.min(...ys),
      maxY: Math.max(...ys),
    };
  }

  update() {
    for (const p of this.particles) p.update();
    for (let i = 0; i < SUBSTEPS; i++) {
      for (const c of this.constraints) c.resolve();
      for (const p of this.particles) p.constrain();
    }
  }

  snapToGroundOrStack(others) {
    const epsilon = 2;
    for (const p of this.particles.slice(2, 4)) { // only bottom two
      if (Math.abs(p.y - canvas.height) < epsilon) {
        p.y = canvas.height;
        p.oldy = p.y;
      } else {
        for (const other of others) {
          if (other === this) continue;
          const aabb = other.getAABB();
          if (
            p.x > aabb.minX && p.x < aabb.maxX &&
            p.y < aabb.minY && Math.abs(p.y - aabb.minY) < epsilon
          ) {
            p.y = aabb.minY;
            p.oldy = p.y;
          }
        }
      }
    }
  }

  draw(ctx) {
    ctx.strokeStyle = "#fff";
    for (const c of this.constraints) c.draw(ctx);
  }
}

const boxes = [];

setInterval(() => {
  boxes.push(new Box(200, 20, 40, 40));
}, 1000);

function update() {
  for (const box of boxes) box.update();
  for (const box of boxes) box.snapToGroundOrStack(boxes);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const box of boxes) box.draw(ctx);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
