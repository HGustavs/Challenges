<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Verlet Physics Boxes</title>
  <style>
    canvas { background: #111; display: block; margin: auto; }
  </style>
</head>
<body>
<canvas id="canvas" width="400" height="600"></canvas>
<script>

/* 

I want to make a minimal physics engine in javascript that supports stacking of boxes that are falling from the top of the screen towards the bottom. The boxes should not fall through the bottom and sides of the screen. I suggest using particles and basing the engine on verlet physics.

* Particles + constraints to form rectangles (boxes)
* Gravity
* Ground and wall collisions
* Stacking support using constraint resolution
* Verlet integration

The boxes are not stacking and are intersection other boxes. Could sorting the boxes vertically help with the stacking behavior? 

Each box:
  *  Checks if its bottom particles are just above another box or the ground.
  *  If so, it snaps them into place by setting y equal to the surface below.

This technique can improve realism and stacking:
  *  Ray = line from old position to new position.
  *  You check where this ray first hits the collision surface (ground, other box, etc).
  *  Compute penetration depth as the overshoot past that surface.
  *  Then push the particle back along the ray direction to eliminate the overlap â€” possibly stopping it at the contact point.
This is called Continuous Collision Detection (CCD), and is especially useful in discrete solvers like Verlet.

*/

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const GRAVITY = 0.5;
const FRICTION = 0.98;
const SUBSTEPS = 5;

class Particle {
  constructor(x, y) {
    this.x = this.oldx = x;
    this.y = this.oldy = y;
  }

  update() {
    const vx = (this.x - this.oldx) * FRICTION;
    const vy = (this.y - this.oldy) * FRICTION + GRAVITY;

    this.oldx = this.x;
    this.oldy = this.y;

    this.x += vx;
    this.y += vy;
  }

  constrain() {
    const radius = 0.5;

    // Left/right walls
    if (this.x < radius) {
      this.x = radius;
      this.oldx = this.x;
    }
    if (this.x > canvas.width - radius) {
      this.x = canvas.width - radius;
      this.oldx = this.x;
    }

    // Floor with ray-based CCD correction
    if (this.y > canvas.height - radius) {
      const dy = this.y - this.oldy;
      const overshoot = this.y - (canvas.height - radius);
      const t = overshoot / dy;
      this.y = canvas.height - radius;
      this.oldy = this.y - dy * (1 - t);
    }

    // Optional: ceiling
    if (this.y < radius) {
      this.y = radius;
      this.oldy = this.y;
    }
  }
}

class Constraint {
  constructor(p1, p2, length = null) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = length ?? this.getLength();
  }

  getLength() {
    const dx = this.p2.x - this.p1.x;
    const dy = this.p2.y - this.p1.y;
    return Math.hypot(dx, dy);
  }

  resolve() {
    const dx = this.p2.x - this.p1.x;
    const dy = this.p2.y - this.p1.y;
    const dist = Math.hypot(dx, dy);
    const diff = (this.length - dist) / dist;

    const offsetX = dx * 0.5 * diff;
    const offsetY = dy * 0.5 * diff;

    this.p1.x -= offsetX;
    this.p1.y -= offsetY;
    this.p2.x += offsetX;
    this.p2.y += offsetY;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.p1.x, this.p1.y);
    ctx.lineTo(this.p2.x, this.p2.y);
    ctx.stroke();
  }
}

class Box {
  constructor(x, y, w, h) {
    const hw = w / 2;
    const hh = h / 2;

    this.particles = [
      new Particle(x - hw, y - hh), // top-left
      new Particle(x + hw, y - hh), // top-right
      new Particle(x + hw, y + hh), // bottom-right
      new Particle(x - hw, y + hh), // bottom-left
    ];

    const [a, b, c, d] = this.particles;

    this.constraints = [
      new Constraint(a, b),
      new Constraint(b, c),
      new Constraint(c, d),
      new Constraint(d, a),
      new Constraint(a, c), // diagonals
      new Constraint(b, d),
    ];
  }

  update() {
    for (const p of this.particles) p.update();

    for (let i = 0; i < SUBSTEPS; i++) {
      for (const c of this.constraints) c.resolve();
      for (const p of this.particles) p.constrain();
    }
  }

  draw(ctx) {
    ctx.strokeStyle = "#fff";
    for (const c of this.constraints) c.draw(ctx);
  }
}

const boxes = [];

function spawnBox() {
  const x = 200;
  const y = 30;
  const w = 40;
  const h = 40;
  boxes.push(new Box(x, y, w, h));
}

setInterval(spawnBox, 1000);

function update() {
  for (const box of boxes) {
    box.update();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const box of boxes) {
    box.draw(ctx);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>