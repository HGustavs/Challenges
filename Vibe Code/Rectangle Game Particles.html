<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Verlet Rectangular Physics</title>
  <style>
    canvas { background: #111; display: block; margin: auto; }
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="400"></canvas>
<script>

/*

https://chatgpt.com/c/6845eeb7-48b0-8002-ab78-4303e6b13547

A minimal particle based verlet physics engine using html5 canvas for rectangular objects consisting of four points and represented using four triangles. The four points are recomputed from velocity and angle each frame. After that the points are updated using gravity and constraints for penetrating into adjacent triangles. From the adjusted points the velocity and angular velocity for the rectangle is updated. 

Creating a minimal Verlet-based physics engine for rectangles using HTML5 canvas, with rectangular objects represented using four points and four triangles, involves several key components:
    Verlet integration for point motion
    Rectangular objects made of 4 points
    Gravity and collision constraints
    Triangle-based collision detection
    Updating velocity and angular velocity from adjusted positions

The square must retain its initial shape every frame update and no point may pass outside the canvas boundaries.

To enforce that:
    The square retains its initial shape exactly (i.e., all edge lengths and angles remain constant).
    No point may pass outside the canvas boundaries.
We need to:
    Keep the four corners constrained as a rigid body using rigid body dynamics principles, not soft constraint corrections.
    After integrating motion, project the rigid body (rectangle) based on its center position and orientation.
    Clamp each point inside the canvas bounds.
    Update the rectangleâ€™s velocity and angular velocity from how much the center and angle changed.

*/

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const gravity = 0.5;
const friction = 0.99;

class RigidRectangle {
  constructor(x, y, w, h, angle = 0) {
    this.w = w;
    this.h = h;

    this.pos = { x, y };
    this.oldPos = { x, y };

    this.angle = angle;
    this.oldAngle = angle;

    this.points = this.computePoints();
  }

  computePoints() {
    const hw = this.w / 2, hh = this.h / 2;
    const c = Math.cos(this.angle);
    const s = Math.sin(this.angle);

    const corners = [
      {x: -hw, y: -hh},
      {x: hw, y: -hh},
      {x: hw, y: hh},
      {x: -hw, y: hh}
    ];

    return corners.map(p => ({
      x: this.pos.x + p.x * c - p.y * s,
      y: this.pos.y + p.x * s + p.y * c
    }));
  }

  verlet() {
    // Compute velocity
    const vx = (this.pos.x - this.oldPos.x) * friction;
    const vy = (this.pos.y - this.oldPos.y) * friction + gravity;
    const va = (this.angle - this.oldAngle) * friction;

    // Save current state
    this.oldPos.x = this.pos.x;
    this.oldPos.y = this.pos.y;
    this.oldAngle = this.angle;

    // Integrate
    this.pos.x += vx;
    this.pos.y += vy;
    this.angle += va;

    // Clamp rectangle inside canvas
    this.clampToBounds();

    // Recompute points
    this.points = this.computePoints();
  }

  clampToBounds() {
    let pts = this.computePoints();

    let dx = 0, dy = 0;
    for (const p of pts) {
      if (p.x < 0) dx = Math.max(dx, 0 - p.x);
      if (p.x > canvas.width) dx = Math.min(dx, canvas.width - p.x);
      if (p.y < 0) dy = Math.max(dy, 0 - p.y);
      if (p.y > canvas.height) dy = Math.min(dy, canvas.height - p.y);
    }

    // Apply shift
    this.pos.x += dx;
    this.pos.y += dy;

    // If rectangle was moved, damp rotation to avoid jitter
    if (dx !== 0 || dy !== 0) {
      this.angle = this.oldAngle;  // Freeze rotation on contact
    }
  }

  draw() {
    ctx.beginPath();
    ctx.moveTo(this.points[0].x, this.points[0].y);
    for (let i = 1; i < this.points.length; i++) {
      ctx.lineTo(this.points[i].x, this.points[i].y);
    }
    ctx.closePath();
    ctx.strokeStyle = "#0f0";
    ctx.stroke();
  }
}

const rect = new RigidRectangle(200, 50, 80, 60, 0.3);

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  rect.verlet();
  rect.draw();

  requestAnimationFrame(update);
}

update();

</script>
</body>
</html>