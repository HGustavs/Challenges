<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Triangle Physics Squares</title>
  <style>
    canvas { background: #111; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>

/*

Lets make a small game using javascript and html5 canvas and a minimal physics engine. The screen consists of a number of randomly placed squares. Each square is composed of two right angle triangles. Each square has a width from 30 to 70 pixels. A minimal physics engine makes sure that the squares do not overlap using collision detection of the triangles and overlapping constraints. The squares start with random rotation angles.

ðŸ§± Step-by-Step Plan
    HTML Canvas Setup
    Define the Square & Triangle Classes
    Triangle-Based Collision Detection
    Physics Loop to update positions and resolve overlaps
    Rendering Loop to draw the scene

Please add rotation physics and  triangle-triangle SAT for realistic collisions.

    Replacing AABB collision detection with triangle-triangle SAT.
    Adding rotation physics, including:
        Angular velocity
        Torque from collisions
        Moment of inertia (approximated)
 
 Add gravity and physics constraints so that squares do not overlap

    Apply gravity: A vertical acceleration pulling each square down.
    Add position constraints to keep squares:
        Within canvas bounds.
        From overlapping using triangle-triangle SAT.
    Improve collision response:
        Basic impulse when overlapping.
        Positional correction to prevent sticking.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRAVITY = 0.2;
const NUM_SQUARES = 10;
const MIN_SIZE = 30;
const MAX_SIZE = 70;
const DAMPING = 0.98;

const squares = [];

class Vec2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  add(v) {
    return new Vec2(this.x + v.x, this.y + v.y);
  }

  sub(v) {
    return new Vec2(this.x - v.x, this.y - v.y);
  }

  scale(s) {
    return new Vec2(this.x * s, this.y * s);
  }

  length() {
    return Math.hypot(this.x, this.y);
  }

  normalize() {
    const len = this.length();
    return len === 0 ? new Vec2(0, 0) : new Vec2(this.x / len, this.y / len);
  }

  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return new Vec2(
      this.x * cos - this.y * sin,
      this.x * sin + this.y * cos
    );
  }

  static dot(a, b) {
    return a.x * b.x + a.y * b.y;
  }
}

class Square {
  constructor(x, y, size, angle) {
    this.pos = new Vec2(x, y);
    this.size = size;
    this.angle = angle;
    this.velocity = new Vec2(0, 0);
    this.angularVelocity = (Math.random() - 0.5) * 0.02;
    this.mass = 1;
    this.inertia = (1 / 6) * this.mass * size * size;
    this.vertices = this.getVertices();
  }

  getVertices() {
    const half = this.size / 2;
    const points = [
      new Vec2(-half, -half),
      new Vec2(half, -half),
      new Vec2(half, half),
      new Vec2(-half, half)
    ];
    return points.map(p => p.rotate(this.angle).add(this.pos));
  }

  getTriangles() {
    this.updateVertices();
    return [
      [this.vertices[0], this.vertices[1], this.vertices[2]],
      [this.vertices[2], this.vertices[3], this.vertices[0]]
    ];
  }

  updateVertices() {
    this.vertices = this.getVertices();
  }

  applyPhysics() {
    this.velocity.y += GRAVITY;
    this.pos = this.pos.add(this.velocity);
    this.angle += this.angularVelocity;
    this.velocity = this.velocity.scale(DAMPING);
    this.angularVelocity *= DAMPING;
    this.updateVertices();
    this.enforceBounds();
  }

  enforceBounds() {
    const half = this.size / 2;

    if (this.pos.x < half) {
      this.pos.x = half;
      this.velocity.x *= -0.5;
    } else if (this.pos.x > canvas.width - half) {
      this.pos.x = canvas.width - half;
      this.velocity.x *= -0.5;
    }

    if (this.pos.y > canvas.height - half) {
      this.pos.y = canvas.height - half;
      this.velocity.y *= -0.5;
    }
  }

  draw(ctx) {
    this.updateVertices();

    ctx.fillStyle = '#0f0';
    ctx.beginPath();
    ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
    ctx.lineTo(this.vertices[1].x, this.vertices[1].y);
    ctx.lineTo(this.vertices[2].x, this.vertices[2].y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#00f';
    ctx.beginPath();
    ctx.moveTo(this.vertices[2].x, this.vertices[2].y);
    ctx.lineTo(this.vertices[3].x, this.vertices[3].y);
    ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
    ctx.closePath();
    ctx.fill();
  }
}

// SAT Helpers
function projectPolygon(axis, vertices) {
  let min = Vec2.dot(axis, vertices[0]);
  let max = min;
  for (let i = 1; i < vertices.length; i++) {
    const p = Vec2.dot(axis, vertices[i]);
    if (p < min) min = p;
    if (p > max) max = p;
  }
  return { min, max };
}

function overlapOnAxis(axis, vertsA, vertsB) {
  const projA = projectPolygon(axis, vertsA);
  const projB = projectPolygon(axis, vertsB);
  return projA.max >= projB.min && projB.max >= projA.min;
}

function getAxes(triangle) {
  const axes = [];
  for (let i = 0; i < triangle.length; i++) {
    const p1 = triangle[i];
    const p2 = triangle[(i + 1) % triangle.length];
    const edge = p2.sub(p1);
    const normal = new Vec2(-edge.y, edge.x);
    const len = normal.length();
    axes.push(new Vec2(normal.x / len, normal.y / len));
  }
  return axes;
}

function triangleSATCollision(triA, triB) {
  const axes = [...getAxes(triA), ...getAxes(triB)];
  for (const axis of axes) {
    if (!overlapOnAxis(axis, triA, triB)) return false;
  }
  return true;
}

// Collision Resolver
function resolveCollisions() {
  for (let i = 0; i < squares.length; i++) {
    for (let j = i + 1; j < squares.length; j++) {
      const a = squares[i];
      const b = squares[j];
      const trisA = a.getTriangles();
      const trisB = b.getTriangles();

      let collided = false;

      for (const triA of trisA) {
        for (const triB of trisB) {
          if (triangleSATCollision(triA, triB)) {
            collided = true;
            break;
          }
        }
        if (collided) break;
      }

      if (collided) {
        // Push apart
        const pushDir = a.pos.sub(b.pos);
        const dist = Math.max(pushDir.length(), 0.001);
        const resolveVec = pushDir.normalize().scale(1);

        a.pos = a.pos.add(resolveVec.scale(0.5));
        b.pos = b.pos.sub(resolveVec.scale(0.5));

        // Invert velocity to simulate bounce
        a.velocity = a.velocity.add(resolveVec.scale(0.1));
        b.velocity = b.velocity.sub(resolveVec.scale(0.1));

        // Spin reaction
        a.angularVelocity += 0.001 * (Math.random() - 0.5);
        b.angularVelocity += 0.001 * (Math.random() - 0.5);

        a.updateVertices();
        b.updateVertices();
      }
    }
  }
}

// Helpers
function random(min, max) {
  return Math.random() * (max - min) + min;
}

function createSquares() {
  for (let i = 0; i < NUM_SQUARES; i++) {
    const size = random(MIN_SIZE, MAX_SIZE);
    const x = random(size, canvas.width - size);
    const y = random(size, canvas.height / 2);
    const angle = random(0, Math.PI * 2);
    squares.push(new Square(x, y, size, angle));
  }
}

// Main Loop
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const square of squares) {
    square.applyPhysics();
  }

  resolveCollisions();

  for (const square of squares) {
    square.draw(ctx);
  }

  requestAnimationFrame(gameLoop);
}

createSquares();
gameLoop();

</script>
</body>
</html>


