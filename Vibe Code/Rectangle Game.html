<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Triangle Physics Squares</title>
  <style>
    canvas { background: #111; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>

/*

Lets make a small game using javascript and html5 canvas and a minimal physics engine. The screen consists of a number of randomly placed squares. Each square is composed of two right angle triangles. Each square has a width from 30 to 70 pixels. A minimal physics engine makes sure that the squares do not overlap using collision detection of the triangles and overlapping constraints. The squares start with random rotation angles.

ðŸ§± Step-by-Step Plan
    HTML Canvas Setup
    Define the Square & Triangle Classes
    Triangle-Based Collision Detection
    Physics Loop to update positions and resolve overlaps
    Rendering Loop to draw the scene

Please add rotation physics and  triangle-triangle SAT for realistic collisions.

    Replacing AABB collision detection with triangle-triangle SAT.
    Adding rotation physics, including:
        Angular velocity
        Torque from collisions
        Moment of inertia (approximated)
 
 Add gravity and physics constraints so that squares do not overlap

    Apply gravity: A vertical acceleration pulling each square down.
    Add position constraints to keep squares:
        Within canvas bounds.
        From overlapping using triangle-triangle SAT.
    Improve collision response:
        Basic impulse when overlapping.
        Positional correction to prevent sticking.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRAVITY = 0.2;
const NUM_SQUARES = 50;
const MIN_SIZE = 30;
const MAX_SIZE = 70;
const DAMPING = 0.98;
const SOLVER_ITERATIONS = 10;
const CORRECTION_BIAS = 0.2; // Correct 20% of overlap per iteration
const OVERLAP_EPSILON = 0.5; // Ignore <0.5px overlaps

const squares = [];

class Vec2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
  sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
  scale(s) { return new Vec2(this.x * s, this.y * s); }
  length() { return Math.hypot(this.x, this.y); }
  normalize() {
    const len = this.length();
    return len === 0 ? new Vec2(0, 0) : this.scale(1 / len);
  }
  rotate(angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return new Vec2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
  }
  static dot(a, b) { return a.x * b.x + a.y * b.y; }
}

class Square {
  constructor(x, y, size, angle) {
    this.pos = new Vec2(x, y);
    this.size = size;
    this.angle = angle;
    this.velocity = new Vec2(0, 0);
    this.angularVelocity = (Math.random() - 0.5) * 0.02;
    this.mass = 1;
    this.inertia = (1 / 6) * this.mass * size * size;
    this.sleepCounter = 0;
    this.sleeping = false;
    this.vertices = this.getVertices();
  }

  getVertices() {
    const half = this.size / 2;
    const points = [
      new Vec2(-half, -half), new Vec2(half, -half),
      new Vec2(half, half), new Vec2(-half, half)
    ];
    return points.map(p => p.rotate(this.angle).add(this.pos));
  }

  getTriangles() {
    this.updateVertices();
    return [
      [this.vertices[0], this.vertices[1], this.vertices[2]],
      [this.vertices[2], this.vertices[3], this.vertices[0]]
    ];
  }

  updateVertices() {
    this.vertices = this.getVertices();
  }

  applyPhysics() {
    if (this.sleeping) return;

    this.velocity.y += GRAVITY;
    this.pos = this.pos.add(this.velocity);
    this.angle += this.angularVelocity;

    this.velocity = this.velocity.scale(DAMPING);
    this.angularVelocity *= DAMPING;
    this.angularVelocity = Math.max(-0.5, Math.min(0.5, this.angularVelocity));
    this.updateVertices();
    this.enforceBounds();
  }

  enforceBounds() {
    const half = this.size / 2;
    if (this.pos.x < half) {
      this.pos.x = half;
      this.velocity.x *= -0.5;
    } else if (this.pos.x > canvas.width - half) {
      this.pos.x = canvas.width - half;
      this.velocity.x *= -0.5;
    }
    if (this.pos.y > canvas.height - half) {
      this.pos.y = canvas.height - half;
      this.velocity.y *= -0.5;
    }
  }

  trySleep() {
    const lowVel = this.velocity.length() < 0.1;
    const lowRot = Math.abs(this.angularVelocity) < 0.01;
    if (lowVel && lowRot) {
      this.sleepCounter++;
      if (this.sleepCounter > 30) {
        this.sleeping = true;
        this.velocity = new Vec2(0, 0);
        this.angularVelocity = 0;
      }
    } else {
      this.sleepCounter = 0;
      this.sleeping = false;
    }
  }

  isResting() {
    const half = this.size / 2;
    const nearBottom = Math.abs(this.pos.y + half - canvas.height) < 2;
    const still = this.velocity.length() < 0.3 && Math.abs(this.angularVelocity) < 0.01;
    return nearBottom || still;
  }

  autoStraighten() {
    const angle = this.angle % (2 * Math.PI);
    const normAngle = ((angle + Math.PI) % (2 * Math.PI)) - Math.PI;
    const ANGLE_THRESHOLD = 0.03;
    const ANGULAR_VELOCITY_THRESHOLD = 0.01;
    if (Math.abs(normAngle) < ANGLE_THRESHOLD &&
        Math.abs(this.angularVelocity) < ANGULAR_VELOCITY_THRESHOLD) {
      this.angle -= normAngle;
      this.angularVelocity = 0;
      return;
    }
    const stiffness = 0.02;
    const damping = 0.15;
    const torque = -normAngle * stiffness - this.angularVelocity * damping;
    this.angularVelocity += torque;
  }

  draw(ctx) {
    this.updateVertices();
    ctx.fillStyle = '#0f0';
    ctx.beginPath();
    ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
    ctx.lineTo(this.vertices[1].x, this.vertices[1].y);
    ctx.lineTo(this.vertices[2].x, this.vertices[2].y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#00f';
    ctx.beginPath();
    ctx.moveTo(this.vertices[2].x, this.vertices[2].y);
    ctx.lineTo(this.vertices[3].x, this.vertices[3].y);
    ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
    ctx.closePath();
    ctx.fill();

    if (this.sleeping) {
      ctx.fillStyle = "#f00";
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// SAT + MTV
function projectPolygon(axis, verts) {
  let min = Vec2.dot(axis, verts[0]);
  let max = min;
  for (let i = 1; i < verts.length; i++) {
    const p = Vec2.dot(axis, verts[i]);
    min = Math.min(min, p);
    max = Math.max(max, p);
  }
  return { min, max };
}

function getAxes(tri) {
  const axes = [];
  for (let i = 0; i < tri.length; i++) {
    const edge = tri[(i + 1) % tri.length].sub(tri[i]);
    axes.push(new Vec2(-edge.y, edge.x).normalize());
  }
  return axes;
}

function triangleSATCollision(triA, triB) {
  const axes = [...getAxes(triA), ...getAxes(triB)];
  let minOverlap = Infinity;
  let smallestAxis = null;
  for (const axis of axes) {
    const projA = projectPolygon(axis, triA);
    const projB = projectPolygon(axis, triB);
    const overlap = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
    if (overlap <= 0) return null;
    if (overlap < minOverlap) {
      minOverlap = overlap;
      smallestAxis = axis;
    }
  }
  return smallestAxis.scale(minOverlap);
}

function isRestingContact(a, b, mtv) {
  const upward = new Vec2(0, -1);
  const mtvDir = mtv.normalize();
  const vertical = Vec2.dot(mtvDir, upward) > 0.7;
  const bAbove = b.pos.y < a.pos.y;
  const speed = b.velocity.sub(a.velocity).length();
  return vertical && bAbove && speed < 1.0;
}

// Final collision resolution
function resolveCollisions() {
  for (let iter = 0; iter < SOLVER_ITERATIONS; iter++) {
    const sorted = [...squares].sort((a, b) => b.pos.y - a.pos.y);
    for (let i = 0; i < sorted.length; i++) {
      const a = sorted[i];
      for (let j = i + 1; j < sorted.length; j++) {
        const b = sorted[j];
        const trisA = a.getTriangles();
        const trisB = b.getTriangles();
        for (const triA of trisA) {
          for (const triB of trisB) {
            const mtv = triangleSATCollision(triA, triB);
            if (mtv) {
              const penetration = mtv.length();
              if (penetration < OVERLAP_EPSILON) continue;

              const correction = mtv.normalize().scale(penetration * CORRECTION_BIAS);

              let pushA = correction.scale(0.1);
              let pushB = correction.scale(0.9);

              if (isRestingContact(a, b, mtv)) {
                pushA = pushA.scale(0.3);
                pushB = pushB.scale(0.3);
              }

              a.pos = a.pos.add(pushA);
              b.pos = b.pos.sub(pushB);
              a.velocity = a.velocity.add(pushA.scale(0.05));
              b.velocity = b.velocity.sub(pushB.scale(0.05));
              a.updateVertices();
              b.updateVertices();
            }
          }
        }
      }
    }
  }
}

// Init + Loop
function random(min, max) {
  return Math.random() * (max - min) + min;
}

function createSquares() {
  for (let i = 0; i < NUM_SQUARES; i++) {
    const size = random(MIN_SIZE, MAX_SIZE);
    const x = random(size, canvas.width - size);
    const y = random(0, canvas.height / 2);
    const angle = random(0, Math.PI * 2);
    squares.push(new Square(x, y, size, angle));
  }
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const s of squares) {
    s.applyPhysics();
    s.trySleep();
    if (s.isResting()) s.autoStraighten();
  }
  resolveCollisions();
  for (const s of squares) s.draw(ctx);
  requestAnimationFrame(gameLoop);
}

createSquares();
gameLoop();

</script>
</body>
</html>


