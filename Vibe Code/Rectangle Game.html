<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Triangle Physics Squares</title>
  <style>
    canvas { background: #111; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>

/*

Lets make a small game using javascript and html5 canvas and a minimal physics engine. The screen consists of a number of randomly placed squares. Each square is composed of two right angle triangles. Each square has a width from 30 to 70 pixels. A minimal physics engine makes sure that the squares do not overlap using collision detection of the triangles and overlapping constraints. The squares start with random rotation angles.

ðŸ§± Step-by-Step Plan
    HTML Canvas Setup
    Define the Square & Triangle Classes
    Triangle-Based Collision Detection
    Physics Loop to update positions and resolve overlaps
    Rendering Loop to draw the scene

Please add rotation physics and  triangle-triangle SAT for realistic collisions.

    Replacing AABB collision detection with triangle-triangle SAT.
    Adding rotation physics, including:
        Angular velocity
        Torque from collisions
        Moment of inertia (approximated)
 
 Add gravity and physics constraints so that squares do not overlap

    Apply gravity: A vertical acceleration pulling each square down.
    Add position constraints to keep squares:
        Within canvas bounds.
        From overlapping using triangle-triangle SAT.
    Improve collision response:
        Basic impulse when overlapping.
        Positional correction to prevent sticking.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRAVITY = 0.2;
const NUM_SQUARES = 50;
const MIN_SIZE = 30;
const MAX_SIZE = 70;
const DAMPING = 0.98;

const squares = [];

class Vec2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  add(v) {
    return new Vec2(this.x + v.x, this.y + v.y);
  }

  sub(v) {
    return new Vec2(this.x - v.x, this.y - v.y);
  }

  scale(s) {
    return new Vec2(this.x * s, this.y * s);
  }

  length() {
    return Math.hypot(this.x, this.y);
  }

  normalize() {
    const len = this.length();
    return len === 0 ? new Vec2(0, 0) : this.scale(1 / len);
  }

  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return new Vec2(
      this.x * cos - this.y * sin,
      this.x * sin + this.y * cos
    );
  }

  static dot(a, b) {
    return a.x * b.x + a.y * b.y;
  }
}

class Square {
  constructor(x, y, size, angle) {
    this.pos = new Vec2(x, y);
    this.size = size;
    this.angle = angle;
    this.velocity = new Vec2(0, 0);
    this.angularVelocity = (Math.random() - 0.5) * 0.02;
    this.mass = 1;
    this.inertia = (1 / 6) * this.mass * size * size;
    this.sleepCounter = 0;
    this.sleeping = false;
    this.vertices = this.getVertices();
  }

  getVertices() {
    const half = this.size / 2;
    const points = [
      new Vec2(-half, -half),
      new Vec2(half, -half),
      new Vec2(half, half),
      new Vec2(-half, half)
    ];
    return points.map(p => p.rotate(this.angle).add(this.pos));
  }

  getTriangles() {
    this.updateVertices();
    return [
      [this.vertices[0], this.vertices[1], this.vertices[2]],
      [this.vertices[2], this.vertices[3], this.vertices[0]]
    ];
  }

  updateVertices() {
    this.vertices = this.getVertices();
  }

  applyPhysics() {
    if (this.sleeping) return;

    this.velocity.y += GRAVITY;
    this.pos = this.pos.add(this.velocity);
    this.angle += this.angularVelocity;

    this.velocity = this.velocity.scale(DAMPING);
    this.angularVelocity *= DAMPING;

    this.angularVelocity = Math.max(-0.5, Math.min(0.5, this.angularVelocity));

    this.updateVertices();
    this.enforceBounds();
  }

  enforceBounds() {
    const half = this.size / 2;

    if (this.pos.x < half) {
      this.pos.x = half;
      this.velocity.x *= -0.5;
    } else if (this.pos.x > canvas.width - half) {
      this.pos.x = canvas.width - half;
      this.velocity.x *= -0.5;
    }

    if (this.pos.y > canvas.height - half) {
      this.pos.y = canvas.height - half;
      this.velocity.y *= -0.5;
    }
  }

  trySleep() {
    const lowVelocity = this.velocity.length() < 0.1;
    const lowRotation = Math.abs(this.angularVelocity) < 0.01;
    if (lowVelocity && lowRotation) {
      this.sleepCounter++;
      if (this.sleepCounter > 30) {
        this.sleeping = true;
        this.velocity = new Vec2(0, 0);
        this.angularVelocity = 0;
      }
    } else {
      this.sleepCounter = 0;
      this.sleeping = false;
    }
  }

  isResting() {
    const half = this.size / 2;
    const nearBottom = Math.abs(this.pos.y + half - canvas.height) < 2;
    const almostStill = this.velocity.length() < 0.3 && Math.abs(this.angularVelocity) < 0.01;
    return nearBottom || almostStill;
  }

  autoStraighten() {
    const angle = this.angle % (2 * Math.PI);
    const normalizedAngle = ((angle + Math.PI) % (2 * Math.PI)) - Math.PI;

    const ANGLE_THRESHOLD = 0.03;
    const ANGULAR_VELOCITY_THRESHOLD = 0.01;

    if (Math.abs(normalizedAngle) < ANGLE_THRESHOLD &&
        Math.abs(this.angularVelocity) < ANGULAR_VELOCITY_THRESHOLD) {
      this.angle -= normalizedAngle;
      this.angularVelocity = 0;
      return;
    }

    const stiffness = 0.02;
    const damping = 0.15;
    const torque = -normalizedAngle * stiffness - this.angularVelocity * damping;

    this.angularVelocity += torque;
  }

  draw(ctx) {
    this.updateVertices();

    ctx.fillStyle = '#0f0';
    ctx.beginPath();
    ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
    ctx.lineTo(this.vertices[1].x, this.vertices[1].y);
    ctx.lineTo(this.vertices[2].x, this.vertices[2].y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#00f';
    ctx.beginPath();
    ctx.moveTo(this.vertices[2].x, this.vertices[2].y);
    ctx.lineTo(this.vertices[3].x, this.vertices[3].y);
    ctx.lineTo(this.vertices[0].x, this.vertices[0].y);
    ctx.closePath();
    ctx.fill();

    if (this.sleeping) {
      ctx.fillStyle = "#f00";
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// --- SAT Collision Detection with MTV ---
function projectPolygon(axis, vertices) {
  let min = Vec2.dot(axis, vertices[0]);
  let max = min;
  for (let i = 1; i < vertices.length; i++) {
    const p = Vec2.dot(axis, vertices[i]);
    if (p < min) min = p;
    if (p > max) max = p;
  }
  return { min, max };
}

function getAxes(triangle) {
  const axes = [];
  for (let i = 0; i < triangle.length; i++) {
    const p1 = triangle[i];
    const p2 = triangle[(i + 1) % triangle.length];
    const edge = p2.sub(p1);
    const normal = new Vec2(-edge.y, edge.x).normalize();
    axes.push(normal);
  }
  return axes;
}

function triangleSATCollision(triA, triB) {
  const axes = [...getAxes(triA), ...getAxes(triB)];

  let minOverlap = Infinity;
  let smallestAxis = null;

  for (const axis of axes) {
    const projA = projectPolygon(axis, triA);
    const projB = projectPolygon(axis, triB);

    const overlap = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
    if (overlap <= 0) return null;

    if (overlap < minOverlap) {
      minOverlap = overlap;
      smallestAxis = axis;
    }
  }

  return smallestAxis.scale(minOverlap);
}

// --- Collision Resolution ---
function resolveCollisions() {
  const ITERATIONS = 5;

  // Sort once per iteration to resolve bottom-up
  for (let iter = 0; iter < ITERATIONS; iter++) {
    const sortedSquares = [...squares].sort((a, b) => b.pos.y - a.pos.y); // bottom to top

    for (let i = 0; i < sortedSquares.length; i++) {
      const a = sortedSquares[i];
      for (let j = i + 1; j < sortedSquares.length; j++) {
        const b = sortedSquares[j];

        const trisA = a.getTriangles();
        const trisB = b.getTriangles();

        for (const triA of trisA) {
          for (const triB of trisB) {
            const mtv = triangleSATCollision(triA, triB);
            if (mtv) {
              // Always push top square (b) more than bottom (a)
              const correction = mtv;

              const totalPush = correction.scale(1.0);
              const pushA = totalPush.scale(0.1); // push bottom slightly
              const pushB = totalPush.scale(0.9); // push top mostly

              a.pos = a.pos.add(pushA);
              b.pos = b.pos.sub(pushB);

              a.velocity = a.velocity.add(pushA.scale(0.1));
              b.velocity = b.velocity.sub(pushB.scale(0.1));

              a.updateVertices();
              b.updateVertices();
            }
          }
        }
      }
    }
  }
}

// --- Setup ---
function random(min, max) {
  return Math.random() * (max - min) + min;
}

function createSquares() {
  for (let i = 0; i < NUM_SQUARES; i++) {
    const size = random(MIN_SIZE, MAX_SIZE);
    const x = random(size, canvas.width - size);
    const y = random(0, canvas.height / 2);
    const angle = random(0, Math.PI * 2);
    squares.push(new Square(x, y, size, angle));
  }
}

// --- Game Loop ---
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const square of squares) {
    square.applyPhysics();
    square.trySleep();
    if (square.isResting()) {
      square.autoStraighten();
    }
  }

  resolveCollisions();

  for (const square of squares) {
    square.draw(ctx);
  }

  requestAnimationFrame(gameLoop);
}

createSquares();
gameLoop();

</script>
</body>
</html>


