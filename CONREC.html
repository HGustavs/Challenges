<html>
	<head>
		
<script src="helperFunction/simplex.js"></script> 
		
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: CONREC algorithm implementation
		
// https://www.youtube.com/watch?v=07hiEtggHXw&t=38s
// http://paulbourke.net/papers/conrec/

var c;

// Coordinate system
const xmax=1430;
const ymax=780;
const origoX=xmax*0.5;
const origoY=ymax*0.5;
var isofact=0.45;

// Mouse controls
var mx,my,mb;
		
// Color index start
var colstart=0;
		
const delay=30;
		
var colors=[[26,19,52],[38,41,74],[1,84,90],[1,115,81],[3,195,131],[170,217,98],[251,191,69],[239,106,50],[237,3,69],[161,42,94],[113,1,98],[2,44,125]];

//----------------------------------------------------------------------------------
// Canvas Setup
//----------------------------------------------------------------------------------
		
function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");
	
		SimplexNoise();			
	
		setTimeout(drawHead,delay);
}
		
//----------------------------------------------------------------------------------
// toIsometric -- Converts from x,y,z to x,y isometric
//----------------------------------------------------------------------------------
		
function toIsometric(xk,yk,zk)
{
		return {
			 x : origoX+xk-zk,
			 y : origoY+(xk*isofact)+(zk*isofact)-yk
		};
}

//----------------------------------------------------------------------------------
// drawCirc -- Draws Circle
//----------------------------------------------------------------------------------

function drawCirc(x,y,r,fill)
{
	c.beginPath();
	c.arc(x, y, r, 0, 2 * 3.1415, false);
	if(fill==true){
			c.fill();	
	}else{
			c.stroke();	
	}
}

//----------------------------------------------------------------------------------
// drawLine3d -- Draws line in 3D
//----------------------------------------------------------------------------------
		
function drawLine3d(x1,y1,z1,x2,y2,z2)
{
	c.beginPath();
	var p1=toIsometric(x1,y1,z1);
	var p2=toIsometric(x2,y2,z2);
	c.moveTo(p1.x,p1.y);
	c.lineTo(p2.x,p2.y);
	c.stroke();	
}
		
function kxm(x1,y1,x2,y2,point)
{
		dy=y2-y1;
		dx=x2-x1;
		k=dy/dx;
		m=y1-(k*x1);
		return (point*k)+m;
}
		
//----------------------------------------------------------------------------------
// conrecLine -- Line
//----------------------------------------------------------------------------------

function conrecLine(p1,p2,p3,plane,gfp)
{
		miny=Math.min(Math.min(p1.y,p2.y),p3.y);
		maxy=Math.max(Math.max(p1.y,p2.y),p3.y);

		// Stop processing if outside plane 
		if(plane<=miny||plane>=maxy) return false;
	
		// Hacky fix for points falling on end-points of segments
		if(plane==p1.y) p1.y+=0.1;
		if(plane==p2.y) p2.y+=0.1;
		if(plane==p3.y) p3.y+=0.1;;	
	
		if(plane>Math.min(p1.y,p2.y)&&plane<Math.max(p1.y,p2.y)){
				xv=kxm(p1.y,p1.x,p2.y,p2.x,plane);
				zv=kxm(p1.y,p1.z,p2.y,p2.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}
		if(plane>Math.min(p2.y,p3.y)&&plane<Math.max(p2.y,p3.y)){
				xv=kxm(p2.y,p2.x,p3.y,p3.x,plane);
				zv=kxm(p2.y,p2.z,p3.y,p3.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}	
		if(plane>=Math.min(p3.y,p1.y)&&plane<Math.max(p3.y,p1.y)){
				xv=kxm(p3.y,p3.x,p1.y,p1.x,plane);
				zv=kxm(p3.y,p3.z,p1.y,p1.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}
	
}

//----------------------------------------------------------------------------------
// conrecQuad - 
//----------------------------------------------------------------------------------

function conrecQuad(p1,p2,p3,p4,plane)
{
		// Create fifth point
		var p5x=(p1.x+p2.x+p3.x+p4.x)/4;
		var p5y=(p1.y+p2.y+p3.y+p4.y)/4;
		var p5z=(p1.z+p2.z+p3.z+p4.z)/4;

		p5={x:p5x,y:p5y,z:p5z};
	
		fp=[];
	
		conrecLine(p1,p2,p5,plane,fp);
		conrecLine(p2,p3,p5,plane,fp);
		conrecLine(p3,p4,p5,plane,fp);
		conrecLine(p4,p1,p5,plane,fp);

		return fp;
}
		
//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
		c.globalAlpha=1.0;
		c.clearRect(0,0,xmax,ymax);

		const offs=20;
		const mapheightstart=0;
		const mapscale=10;
		const mapheight=70;
		const mapstart=200;
		const mapcnt=Math.ceil((mapstart*2)/offs);
		const mapheightcnt=4;
		const mapoffs=(mapheight-mapheightstart)/mapheightcnt;
	
		var map=[];
		
		// Construct map and assign low edges
		for(var i=0;i<mapcnt;i++){
				map[i]=[];
				for(var j=0;j<mapcnt;j++){
						map[i][j]=Math.abs(noise2D(i/mapscale,j/mapscale)*mapheight);
						if((j==0)||(i==0)||(j==(mapcnt-1))||(i==(mapcnt-1))){
								map[i][j]=-mapheightstart+1;										
						}
				}
		}
	
		var segmentlist=[];
		
		// Prepare Segment Map
		for(var k=0;k<mapheightcnt;k++){
				segmentlist[k]=[];
		}	
	
		// CONREC
		for(var i=0;i<(mapcnt-1);i++){	
				for(var j=0;j<(mapcnt-1);j++){
						p1={x:(i*offs)-mapstart,y:map[i][j],z:(j*offs)-mapstart};
						p2={x:(i*offs)-mapstart+offs,y:map[i+1][j],z:(j*offs)-mapstart};
						p3={x:(i*offs)-mapstart+offs,y:map[i+1][j+1],z:(j*offs)-mapstart+offs};
						p4={x:(i*offs)-mapstart,y:map[i][j+1],z:(j*offs)-mapstart+offs};		
					
						// Add to segments
						for(var k=0;k<mapheightcnt;k++){
							
								segs=conrecQuad(p1,p2,p3,p4,mapheightstart+(k*mapoffs));
							
								// Iterate over segments
								for(var l=0;l<segs.length;l+=2){
										var x1=Math.round(segs[l].x);
										var y1=Math.round(segs[l].z);
										var x2=Math.round(segs[l+1].x);
										var y2=Math.round(segs[l+1].z);
								
										var found=false;
										segments=segmentlist[k];
										// 
										for(m=0;m<segments.length;m++){
												ps=segments[m][0];
												pe=segments[m][segments[m].length-1];
												if((ps.x==x1)&&(ps.y==y1)){
														// If equal to start segment place p2 first
														segments[m].unshift({x:x2,y:y2});
														found=true;
														break;
												}
												if((pe.x==x1)&&(pe.y==y1)){
														// If equal to end segment place p2 last
														segments[m].push({x:x2,y:y2});
														found=true;
														break;												
												}
												if((ps.x==x2)&&(ps.y==y2)){
														// If equal to start segment place p2 first
														segments[m].unshift({x:x1,y:y1});
														found=true;
														break;
												}
												if((pe.x==x2)&&(pe.y==y2)){
														// If equal to end segment place p2 last
														segments[m].push({x:x1,y:y1});
														found=true;
														break;												
												}											
										}
										// No segment found - create new segment
										if(found==false){
												//console.log("Not found: "+k);
												segment=[];
												segment.push({x:x1,y:y1});
												segment.push({x:x2,y:y2});
												segments.push(segment);
										}
								}
						}
				}
		}
	
		// join segments
		for(var k=1;k<2;k++){
				segments=segmentlist[k];
				var segcnt=0;
				for(var l=0;l<segments.length;l++){
						var outerseg=segments[l];
						ps=outerseg[0];
						pe=outerseg[outerseg.length-1];
						if(outerseg.finished!=true){
								for(var m=0;m<segments.length;m++){
										if(m!=l){
												var innerseg=segments[m];
												ips=innerseg[0];
												ipe=innerseg[innerseg.length-1];
												if((pe.x==ipe.x)&&(pe.y==ipe.y)){
														console.log("SAME END!");
														// Same end means we must reverse -- Outer: 2,4,5 Inner:7,6,5
														for(var o=(innerseg.length-2);o>0;o--){
																outerseg.push(innerseg[o]);
														}
														innerseg.finished=true;
												}
												if((ps.x==ips.x)&&(ps.y==ips.y)){
														// Same start means we must copy from second element  -- Outer: 2,4,5 Inner:2,1,3											
														console.log("SAME START!");
														for(var o=1;o<innerseg.length;o++){
																outerseg.unshift(innerseg[o]);
														}
														innerseg.finished=true;
												}
												if((pe.x==ips.x)&&(pe.y==ips.y)){
														
														// Same start as end  -- Outer: 2,4,5 Inner:5,7,8											
														console.log("SAME START as END!");
														for(var o=1;o<innerseg.length;o++){
																outerseg.push(innerseg[o]);
														}
														
														innerseg.finished=true;
												}											
										}
								}
						}else{
								segcnt++;
						}
				}
				console.log("     ",k,segments.length,segcnt);
			
		}
	
	
		for(var k=1;k<2;k++){
				segments=segmentlist[k];
				for(var l=0;l<segments.length;l++){
						pnts=segments[l];
						// console.log(pnts.length,pnts);
						if(pnts.finished==true){
								c.fillStyle="#000";
						}else{
								c.fillSTyle="#080";
						}
						if(pnts.length>9){
								for(var m=0;m<pnts.length-1;m++){
										var pnt1=pnts[m];
										var pnt2=pnts[m+1];
										c.beginPath();
										c.moveTo(origoX+pnt1.x,origoY+pnt1.y);
										c.lineTo(origoX+pnt2.x,origoY+pnt2.y);
										c.stroke();
										//drawCirc(origoX+pnt.x,origoY+pnt.y,2,false);
								}
						}
				}
		}
	
}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>