<html>
	<head>
		
<script src="helperFunction/simplex.js"></script> 
		
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: CONREC algorithm implementation
		
// https://www.youtube.com/watch?v=07hiEtggHXw&t=38s
// http://paulbourke.net/papers/conrec/

var c;

// Coordinate system
const xmax=1430;
const ymax=780;
const origoX=xmax*0.5;
const origoY=ymax*0.5;
var isofact=0.45;

// Mouse controls
var mx,my,mb;
		
// Color index start
var colstart=0;
		
const delay=30;
		
var colors=[[26,19,52],[38,41,74],[1,84,90],[1,115,81],[3,195,131],[170,217,98],[251,191,69],[239,106,50],[237,3,69],[161,42,94],[113,1,98],[2,44,125]];

//----------------------------------------------------------------------------------
// Canvas Setup
//----------------------------------------------------------------------------------
		
function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");
	
		SimplexNoise();			
	
		setTimeout(drawHead,delay);
}
		
//----------------------------------------------------------------------------------
// toIsometric -- Converts from x,y,z to x,y isometric
//----------------------------------------------------------------------------------
		
function toIsometric(xk,yk,zk)
{
		return {
			 x : origoX+xk-zk,
			 y : origoY+(xk*isofact)+(zk*isofact)-yk
		};
}

//----------------------------------------------------------------------------------
// drawCirc -- Draws Circle
//----------------------------------------------------------------------------------

function drawCirc(x,y,r,fill)
{
	c.beginPath();
	c.arc(x, y, r, 0, 2 * 3.1415, false);
	if(fill==true){
			c.fill();	
	}else{
			c.stroke();	
	}
}

//----------------------------------------------------------------------------------
// drawLine3d -- Draws line in 3D
//----------------------------------------------------------------------------------
		
function drawLine3d(x1,y1,z1,x2,y2,z2)
{
	c.beginPath();
	var p1=toIsometric(x1,y1,z1);
	var p2=toIsometric(x2,y2,z2);
	c.moveTo(p1.x,p1.y);
	c.lineTo(p2.x,p2.y);
	c.stroke();	
}
		
function kxm(x1,y1,x2,y2,point)
{
		dy=y2-y1;
		dx=x2-x1;
		k=dy/dx;
		m=y1-(k*x1);
		return (point*k)+m;
}
		
//----------------------------------------------------------------------------------
// conrecLine -- Line
//----------------------------------------------------------------------------------

function conrecLine(p1,p2,p3,plane,gfp)
{
		miny=Math.min(Math.min(p1.y,p2.y),p3.y);
		maxy=Math.max(Math.max(p1.y,p2.y),p3.y);

		// Stop processing if outside plane 
		if(plane<=miny||plane>=maxy) return false;
	
		// Hacky fix for points falling on end-points of segments
		if(plane==p1.y) p1.y+=0.1;
		if(plane==p2.y) p2.y+=0.1;
		if(plane==p3.y) p3.y+=0.1;;	
	
		if(plane>Math.min(p1.y,p2.y)&&plane<Math.max(p1.y,p2.y)){
				xv=kxm(p1.y,p1.x,p2.y,p2.x,plane);
				zv=kxm(p1.y,p1.z,p2.y,p2.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}
		if(plane>Math.min(p2.y,p3.y)&&plane<Math.max(p2.y,p3.y)){
				xv=kxm(p2.y,p2.x,p3.y,p3.x,plane);
				zv=kxm(p2.y,p2.z,p3.y,p3.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}	
		if(plane>=Math.min(p3.y,p1.y)&&plane<Math.max(p3.y,p1.y)){
				xv=kxm(p3.y,p3.x,p1.y,p1.x,plane);
				zv=kxm(p3.y,p3.z,p1.y,p1.z,plane);
				gfp.push({x:xv,y:plane,z:zv});
		}
	
}

//----------------------------------------------------------------------------------
// conrecQuad - 
//----------------------------------------------------------------------------------

function conrecQuad(p1,p2,p3,p4,plane)
{
		// Create fifth point
		var p5x=(p1.x+p2.x+p3.x+p4.x)/4;
		var p5y=(p1.y+p2.y+p3.y+p4.y)/4;
		var p5z=(p1.z+p2.z+p3.z+p4.z)/4;

		p5={x:p5x,y:p5y,z:p5z};
	
		fp=[];
	
		conrecLine(p1,p2,p5,plane,fp);
		conrecLine(p2,p3,p5,plane,fp);
		conrecLine(p3,p4,p5,plane,fp);
		conrecLine(p4,p1,p5,plane,fp);

		return fp;
}

//----------------------------------------------------------------------------------
// popDualArray - Remove an element from both dual arrays or null
//----------------------------------------------------------------------------------
		
function popDualArray(arr1,arr2)
{
		for (var l in arr1){
				console.log("START!",l);
				retobj=arr1[l];
				//delete arr1[l];
				//delete arr2[retobj.ekey];
				return retobj;
		}		
}

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
		c.globalAlpha=1.0;
		c.clearRect(0,0,xmax,ymax);

		const offs=20;
		const mapheightstart=0;
		const mapscale=10;
		const mapheight=70;
		const mapstart=200;
		const mapcnt=Math.ceil((mapstart*2)/offs);
		const mapheightcnt=4;
		const mapoffs=(mapheight-mapheightstart)/mapheightcnt;
	
		var map=[];
		
		// Construct map and assign low edges
		for(var i=0;i<mapcnt;i++){
				map[i]=[];
				for(var j=0;j<mapcnt;j++){
						map[i][j]=Math.abs(noise2D(i/mapscale,j/mapscale)*mapheight);
						if((j==0)||(i==0)||(j==(mapcnt-1))||(i==(mapcnt-1))){
								map[i][j]=-mapheightstart+1;										
						}
				}
		}
	
		var slinelist=[];
		var elinelist=[];
		var segmentlist=[]
		
		// Prepare Segment Map
		for(var k=0;k<mapheightcnt;k++){
				slinelist[k]=[];
				elinelist[k]=[];
				segmentlist[k]=[];
		}	
	
		// CONREC
		for(var i=0;i<(mapcnt-1);i++){	
				for(var j=0;j<(mapcnt-1);j++){
						p1={x:(i*offs)-mapstart,y:map[i][j],z:(j*offs)-mapstart};
						p2={x:(i*offs)-mapstart+offs,y:map[i+1][j],z:(j*offs)-mapstart};
						p3={x:(i*offs)-mapstart+offs,y:map[i+1][j+1],z:(j*offs)-mapstart+offs};
						p4={x:(i*offs)-mapstart,y:map[i][j+1],z:(j*offs)-mapstart+offs};		
					
						// Add to segments
						for(var k=0;k<mapheightcnt;k++){
							
								segs=conrecQuad(p1,p2,p3,p4,mapheightstart+(k*mapoffs));
							
								// Iterate over segments
								for(var l=0;l<segs.length;l+=2){
										var vx1=Math.round(segs[l].x);
										var vy1=Math.round(segs[l].z);
										var vx2=Math.round(segs[l+1].x);
										var vy2=Math.round(segs[l+1].z);
										var vskey="K"+vx1+vy1;
										var vekey="K"+vx2+vy2;									
										lineobj={x1:vx1,y1:vy1,x2:vx2,y2:vy2,skey:vskey,ekey:vekey};
										slinelist[k][vskey]=lineobj;
										elinelist[k][vekey]=lineobj;
								}
						}
				}
		}

		// repeat until nothing is found OR we return to first point
		points=[];
		slist=slinelist[1];
		elist=elinelist[1];
		retobj=popDualArray(slist,elist);
		startx=retobj.x1;
		starty=retobj.y1;
		ekey=retobj.ekey;
		points.push({x:retobj.x1,y:retobj.y1});
		points.push({x:retobj.x2,y:retobj.y2});
	
		console.log(slist);
	
		for(var i=0;i<10;i++){
				console.log(ekey,slist[ekey],elist[ekey]);
				if(typeof slist[ekey]!="undefined"){
						retobj=slist[ekey];
						delete slist[ekey];
						ekey=retobj.ekey;
						points.push({x:retobj.x2,y:retobj.y2});
						console.log("found start")
				}else if(typeof elist[ekey]!="undefined"){
						retobj=elist[ekey];
						delete elist[ekey];
						ekey=retobj.skey;
						points.push({x:retobj.x1,y:retobj.y1});
						console.log("found end");
				}else{
						break;				 
				}
		}

	
		// Draw points for testing purposes
		for(var k=0;k<points.length;k++){
				var pnt=points[k];
				drawCirc(origoX+pnt.x,origoY+pnt.y,3,true);
		}
/*	
		for(var k=1;k<2;k++){
				segments=segmentlist[k];
				for(var l=0;l<segments.length;l++){
						pnts=segments[l];
						// console.log(pnts.length,pnts);
						if(pnts.finished==true){
								c.fillStyle="#000";
						}else{
								c.fillSTyle="#080";
						}
						if(pnts.length>9){
								for(var m=0;m<pnts.length-1;m++){
										var pnt1=pnts[m];
										var pnt2=pnts[m+1];
										c.beginPath();
										c.moveTo(origoX+pnt1.x,origoY+pnt1.y);
										c.lineTo(origoX+pnt2.x,origoY+pnt2.y);
										c.stroke();
										//drawCirc(origoX+pnt.x,origoY+pnt.y,2,false);
								}
						}
				}
		}
*/	
}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>