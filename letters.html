<html>
	<head>
	<script>
//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Make animated scrabble area game with smallest amount of code
		
// Algorithm
// After the game is over (time is up in a timed game, or there are no more words are available to be played), you get points for the bears on the board. Each bear is worth the number of spaces it occupies, to the 1.85th power. See the screenshot below.
// For every letter tile you use when spelling a word, the number of points you get is the multiplier times that tile's counter. For example, the tile shown above currently has a counter of 2. If you use it to spell a word on this turn, you'll get 5 x 2 = 10 points. These points are shown to you in the Submit bar as you build the word, and are credited immediately at the time you submit the word.

		
var c;
var gover=false;
var gridX=7;
var gridY=6;
var perc=1.0;
var upd=true;
var gamegrid=[];
var anim=[];
var cards=[];
var nextcard=-1;
var highest=6;
var tilestartX=20;
var tilestartY=20;
var tilegridX=70;
var tilegridY=70;
var tileW=66;
var tileH=66;
var scores=[0,3,9,27,81,243,729,2187,6561,19683,59049,177147];
var score=0;
var newitems=null;
var olditems=null;
	
function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");
	
		// Clear Grid
		for(var i=0;i<(gridX*gridY);i++){
				gamegrid[i]={kind:0,visited:false};
		}	
	
		gamegrid[8]={kind:1,visited:false};	
		gamegrid[9]={kind:1,visited:false};
		gamegrid[10]={kind:1,visited:false};
		gamegrid[11]={kind:1,visited:false};
		gamegrid[16]={kind:1,visited:false};	
		gamegrid[17]={kind:1,visited:false};		
		gamegrid[23]={kind:1,visited:false};	
		gamegrid[24]={kind:1,visited:false};	
		gamegrid[30]={kind:1,visited:false};	
		gamegrid[37]={kind:1,visited:false};		
	
		drawHead();
	
		gamegrid[18]={kind:1,visited:false};
		gamegrid[25]={kind:1,visited:false};
	
		drawHead();	
}
		
function drawText(tex,xk,yk,fillcol,outlinecol,fontsize,fontfamily)
{
		c.textAlign = "center"; 
		c.textBaseline = "middle"; 
		c.font=fontsize+" "+fontfamily;	
		
		if(outlinecol!=""){
				c.lineWidth = 6;
				c.strokeStyle=outlinecol;
				c.strokeText(tex,xk,yk);
				c.lineWidth = 1;
		}
		c.fillStyle=fillcol;
		c.fillText(tex,xk,yk);
}

//----------------------------------------------------------------------------------
// drawSymbol - Draw a symbol with rounded corners
//----------------------------------------------------------------------------------
		
function drawSymbol(xk,yk,w,h,val,nval,perc)
{
		var r=8;
		c.beginPath();
		c.moveTo(xk+r,yk);
		c.lineTo(xk+w-r,yk);
		c.quadraticCurveTo(xk+w,yk,xk+w,yk+r);
		c.lineTo(xk+w,yk+h-r);
		c.quadraticCurveTo(xk+w,yk+h,xk+w-r,yk+h);
		c.lineTo(xk+r,yk+h);
		c.quadraticCurveTo(xk,yk+h,xk,yk+h-r);
		c.lineTo(xk,yk+r);
		c.quadraticCurveTo(xk,yk,xk+r,yk);
	
		if(val==0){
				c.stroke();		
		}else{
				if(val==1) c.fillStyle="#f28";
				if(val==2) c.fillStyle="#28f";
				if(val>2||nval>2) c.fillStyle="#ac2";				
				if(gover) c.fillStyle="#555";
				c.fill();
			
				if(nval==highest) drawText(nval,xk+(w*0.5),yk+(h*0.5),"#A25","","30px","Comic Sans MS");
				else drawText(nval,xk+(w*0.5),yk+(h*0.5),"#000","","30px","Comic Sans MS");
							
				if(gover&&nval>=3){
						leFunc=scores[notoIndex(nval)];
						drawText("+"+leFunc,xk+(w*0.5),yk+(h*0.1),"#FFF","#000","20px","Comic Sans MS");
						score+=leFunc;
				}
		}
}
		
document.onkeydown = checkKey;

function checkKey(e) {
		if(perc==1.0&&gover==false){
				if (e.keyCode == '38') progressGrid(0,-1);
				if (e.keyCode == '40') progressGrid(0,1);
				if (e.keyCode == '37') progressGrid(-1,0);
				if (e.keyCode == '39') progressGrid(1,0);
		}
}		

//----------------------------------------------------------------------------------
// animate - Animate tile positions
//----------------------------------------------------------------------------------	

function animate(perc)
{
		// Draw Grid
		for(var i=0;i<gridX;i++){
				for(var j=0;j<gridY;j++){
						drawSymbol(tilestartX+(i*tilegridX),tilestartY+(j*tilegridY),tileW,tileH,0);
				}
		}		
	
		// Draw animating tiles
		for(var i=0;i<anim.length;i++){
				item=anim[i];
				xk=item.fx+((item.tx-item.fx)*perc);
				yk=item.fy+((item.ty-item.fy)*perc);
				drawSymbol(tilestartX+(xk*tilegridX),tilestartY+(yk*tilegridY),tileW,tileH,item.ns,item.ne,perc);
		}
}
		
//----------------------------------------------------------------------------------
// findArea - Compute largest possible rectangular area around x,y point in grid
//----------------------------------------------------------------------------------	
		
function findArea(currx,curry)
{
		if(gamegrid[(gridX*curry)+currx].kind!=1) return null;
	
		var yk=curry;
		var minx=100;
		var maxarea=0;
		var maxw=0;
		var maxh=0;

		while(gamegrid[(gridX*yk)+currx].kind==1&&gamegrid[(gridX*yk)+currx].visited==false){
				var xk=currx;
				while(gamegrid[(gridX*yk)+xk].kind==1&&gamegrid[(gridX*yk)+xk].visited==false&&xk<gridX){
						xk++;		
				}
				if(xk<minx) minx=xk;

				yk++;
				var area=(minx-currx)*(yk-curry);
				if(area>maxarea){
							maxw=(minx-currx);
							maxh=(yk-curry);
							maxarea=area;
				}
				if(yk>=gridY) break;
		}
		return {area:maxarea,x1:currx,y1:curry,w:maxw,h:maxh,x2:currx+maxw,y2:curry+maxh,visited:false};
}

//----------------------------------------------------------------------------------
// setArea - Set specific value on game area
//----------------------------------------------------------------------------------	
		
function setArea(xk,yk,w,h,val)
{
		for(var i=yk;i<(yk+h);i++){
				for(var j=xk;j<(xk+w);j++){
						gamegrid[(gridX*i)+j].visited=val;
				}
		}
}
		
//----------------------------------------------------------------------------------
// overlap - Standard 2d colision detection
//----------------------------------------------------------------------------------	
		
function overlap(x1,y1,x2,y2,x3,y3,x4,y4)
{
		if(x2<x3||x1>x4||y2<y3||y1>y4) return false;
		return true;
}

//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
		if(perc<1.0||upd==true) c.clearRect(0,0,700,700);
	
		setArea(0,0,gridX,gridY,false);
	
		olditems=newitems;
		newitems=[];

		do{
				var maxitem={area:0};
				for(var j=0;j<gridY;j++){
						for(var i=0;i<gridX;i++){
								var area=findArea(i,j);
								if(area!=null){
										if(area.area>maxitem.area){
												maxitem=area;
										}
								}
						}
				}
				if(maxitem.area>0){
						newitems.push(maxitem);
						setArea(maxitem.x1,maxitem.y1,maxitem.w,maxitem.h,true);
				}
		}while(maxitem.area>0);
	
		// Draw game grid
		for(var j=0;j<gridY;j++){
				for(var i=0;i<gridX;i++){
						drawSymbol(tilestartX+(i*tilegridX),tilestartY+(j*tilegridY),tileW,tileH,gamegrid[(j*gridX)+i].kind,gamegrid[(j*gridX)+i].kind,1.0);
				}
		}
	
		// For every old item check for overlapping new items and animate accordingly
		if(olditems!=null){
				for(var i=0;i<olditems.length;i++){
						var olditem=olditems[i];
						var found=0;
						for(j=0;j<newitems.length;j++){
								var newitem=newitems[j];
								if(overlap(olditem.x1,olditem.y1,olditem.x2,olditem.y2,newitem.x1,newitem.y1,newitem.x2,newitem.y2)&&newitem.visited==false){
										newitem.visited=true;
										console.log("Ov UV",olditem,newitem);
										found=1;
										break;
								}else if(overlap(olditem.x1,olditem.y1,olditem.x2,olditem.y2,newitem.x1,newitem.y1,newitem.x2,newitem.y2)&&newitem.visited==true){
										console.log("Ov VI",olditem,newitem);
										found=2;							
								}
						}
						console.log(found);
						// If no overlap -- hide items
				}
		}
		
		// window.requestAnimationFrame(drawHead);
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=700 height=700 style='border:1px solid red;' ></canvas>	
	</body>

</html>