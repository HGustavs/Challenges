<html>
<head>
		<script>
				var ctx;
			  var mx,my,mb=0;

        const drawscale=5;
			
        // Ear Clipping
        // https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
        // https://twitter.com/sebastianlague/status/888813623962894337
        // https://en.wikipedia.org/wiki/Polygon_triangulation

        // Structure: Linked list with previous and next
        // An ear is is a convex vertex that has a diagonal completely inside the polygon
        // We test reflex vertices for containment
        //   If adjacent is convex it remains convex
        //   If adjacent is ear it may not remain an ear
        //   If the adjacent vertex is reflex, it may become convex and an ear

        // TestEar - Go through array of all elements and check convex for inside

        var points=[
          {x:0,y:42},
          {x:44,y:32},
          {x:16,y:60},
          {x:4,y:82},
          {x:24,y:108},
          {x:65,y:136},
          {x:93,y:116},
          {x:33,y:91},
          {x:60,y:53},
          {x:55,y:81},
          {x:86,y:66},
          {x:60,y:40}, 
          {x:93,y:28},
          {x:79,y:0}, 
          {x:46,y:9}, 
        ];

        var segs=[];

        var triangles=[];

				function setup()
				{
						var cc = document.getElementById("myCanvas");
				    ctx = cc.getContext("2d");
					
						setInterval(updatestate,20);

						drawit();
				}
								
				function updatestate()
				{

				}
			
				function mouseUp(e)
				{
						mb=0;
				}
			
				function mouseDown(e)
				{
						mb=e.which;
				}
			
				function mouseMove(e,t)
				{
						var rect = e.target.getBoundingClientRect();
            mx = e.clientX - rect.left; //x position within the element.
            my = e.clientY - rect.top;  //y position within the element
				}

        function circ(x,y,color)
        {
            ctx.beginPath();
            ctx.fillStyle=color;
            ctx.arc(x*drawscale,y*drawscale, 5, 0, 6.28);
            ctx.fill();
            ctx.stroke();
        }

        function isConvex(p1,p2,p3)
        {
            return Math.sign((p3.x - p1.x) * (-p2.y + p1.y) + (p3.y - p1.y) * (p2.x - p1.x))==-1;
        }

        function isInsideTriangle(a,b,c,p)
        {
            var area = 0.5*(-b.y * c.x + a.y * (-b.x + c.x) + a.x * (b.y - c.y) + b.x * c.y);
            var s = 1 / (2 * area) * (a.y * c.x - a.x * c.y + (c.y - a.y) * p.x + (a.x - c.x) * p.y);
            var t = 1 / (2 * area) * (a.x * b.y - a.y * b.x + (a.y - b.y) * p.x + (b.x - a.x) * p.y);
            return s >= 0 && t >= 0 && (s + t) <= 1;          
        }
			
        function mod(x,m)
        {
            return ((x%m)+m)%m;
        }

        function inside(p1,p2,p3)
        {
            // We test reflex vertices
            for(var i=0;i<segs.length;i++){
                var pnt=segs[i];
                if(pnt.convex!=true&&pnt.index!=p1.index&&pnt.index!=p2.index&&pnt.index!=p3.index){
                  console.log(pnt.convex,p1.index,p2.index,p3.index);
                  if(isInsideTriangle(p1,p2,p3,pnt)) return true;
                }
            }
            return false;
        }

        function visualize()
        {
            // Show all ears found
            for(var i=0;i<segs.length;i++){
                if(segs[i].ear){
                    ctx.strokeStyle="#cd8";
                    ctx.beginPath();
                    ctx.moveTo(segs[i].prev.x*drawscale,segs[i].prev.y*drawscale);
                    ctx.lineTo(segs[i].x*drawscale,segs[i].y*drawscale);
                    ctx.lineTo(segs[i].next.x*drawscale,segs[i].next.y*drawscale);
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            
            // Show reflex/convex segs and indices
            for(var i=0;i<segs.length;i++){
                var color;
                if(segs[i].convex){
                    color="#bb8"
                }else{
                    color="#48b";
                }

                ctx.fillStyle="#000";
                ctx.fillText(segs[i].index, (segs[i].x+4)*drawscale, segs[i].y*drawscale);

                circ(segs[i].x,segs[i].y,color);                
            }
            ctx.strokeStyle="#000";
        }

        function evaluate(pnt)
        {
            if(pnt.convex){
                return !inside(pnt.prev,pnt,pnt.next);
            }else{
                return false;
            }            
        }

				function drawit()
				{	
						ctx.clearRect(0,0,900,900);
						
            ctx.font="20px Arial Narrow";
            
            // Initiate segments list
            for(var i=0;i<points.length;i++){
                segs.push({x:points[i].x,y:points[i].y});
            }

            // Prepare previous, next and current linked list
            for(var i=0;i<segs.length;i++){
                segs[i].index=i;
                segs[i].prev=segs[mod(i-1,segs.length)];
                segs[i].next=segs[mod(i+1,segs.length)];
                segs[i].convex=isConvex(segs[i].prev,segs[i],segs[i].next);
            }

            ctx.beginPath();
            ctx.strokeStyle="#cc8";
            ctx.setLineDash([5, 5]);
            for(var i=0;i<segs.length;i++){
                ctx.moveTo(segs[i].x*drawscale,segs[i].y*drawscale);
                ctx.lineTo(segs[(i+1)%segs.length].x*drawscale,segs[(i+1)%segs.length].y*drawscale);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle="#000";

            // Inside tests must happen after we prepare reflex/convex state for all segs
            for(var i=0;i<segs.length;i++){
                segs[i].ear=evaluate(segs[i]);
            }
            
            do{
                // Find an ear and remove it
                for(var i=0;i<segs.length;i++){
                    if(segs[i].ear){
                        // Set up previous and next elements to point around current element
                        segs[i].prev.next=segs[i].next;
                        segs[i].next.prev=segs[i].prev;
                        if(!segs[i].prev.convex){
                            segs[i].prev.convex=isConvex(segs[i].prev.prev,segs[i].prev,segs[i].prev.next);                
                        }
                        if(!segs[i].next.convex){
                            segs[i].next.convex=isConvex(segs[i].next.prev,segs[i].next,segs[i].next.next);                
                        }
                        segs[i].prev.ear=evaluate(segs[i].prev);
                        segs[i].next.ear=evaluate(segs[i].next);
                        triangles.push({p1:segs[i].prev.index,p2:segs[i].index,p3:segs[i].next.index});
                        segs.splice(i,1);
                        break;
                    }
                }
            }while(segs.length>2) 
            console.log(triangles);

            /*
            visualize();
            ctx.beginPath();
            for(var i=0;i<segs.length;i++){
                ctx.moveTo(segs[i].x*drawscale,segs[i].y*drawscale);
                ctx.lineTo(segs[(i+1)%segs.length].x*drawscale,segs[(i+1)%segs.length].y*drawscale);
            }
            ctx.stroke();
            */

            for(var i=0;i<triangles.length;i++){
                ctx.beginPath();
                ctx.moveTo(points[triangles[i].p1].x*drawscale,points[triangles[i].p1].y*drawscale);
                ctx.lineTo(points[triangles[i].p2].x*drawscale,points[triangles[i].p2].y*drawscale);
                ctx.lineTo(points[triangles[i].p3].x*drawscale,points[triangles[i].p3].y*drawscale);
                ctx.closePath();
                ctx.stroke();
            }

   						// window.requestAnimationFrame(drawit);
				} 			
						
		</script>
</head>
<body onload="setup();">
 	<canvas id="myCanvas" onmousedown="mouseDown(event);" onmouseup="mouseUp(event);" onmousemove="mouseMove(event,this);" width="900" height="900" style="border:1px solid #000000;"></canvas> 
</body>
