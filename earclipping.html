<html>
<head>
		<script>
				var ctx;
			  var mx,my,mb=0;

        const drawscale=5;
			
        // Ear Clipping
        // https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
        // https://twitter.com/sebastianlague/status/888813623962894337
        // https://en.wikipedia.org/wiki/Polygon_triangulation

        // Structure: Linked list with previous and next
        // An ear is is a convex vertex that has a diagonal completely inside the polygon
        // We test reflex vertices for containment
        //   If adjacent is convex it remains convex
        //   If adjacent is ear it may not remain an ear
        //   If the adjacent vertex is reflex, it may become convex and an ear

        // TestEar - Go through array of all elements and check convex for inside

        var points=[
          {x:0,y:42},
          {x:44,y:32},
          {x:16,y:60},
          {x:4,y:82},
          {x:24,y:108},
          {x:65,y:136},
          {x:93,y:116},
          {x:33,y:91},
          {x:60,y:53},
          {x:55,y:81},
          {x:86,y:66},
          {x:60,y:40}, 
          {x:93,y:28},
          {x:79,y:0}, 
          {x:46,y:9}, 
        ];

				function setup()
				{
						var cc = document.getElementById("myCanvas");
				    ctx = cc.getContext("2d");
					
						setInterval(updatestate,20);

						drawit();
				}
								
				function updatestate()
				{

				}
			
				function mouseUp(e)
				{
						mb=0;
				}
			
				function mouseDown(e)
				{
						mb=e.which;
				}
			
				function mouseMove(e,t)
				{
						var rect = e.target.getBoundingClientRect();
            mx = e.clientX - rect.left; //x position within the element.
            my = e.clientY - rect.top;  //y position within the element
				}

        function circ(x,y,color)
        {
            ctx.beginPath();
            ctx.fillStyle=color;
            ctx.arc(x*drawscale,y*drawscale, 5, 0, 6.28);
            ctx.fill();
            ctx.stroke();
        }

        function isConvex(p1,p2,p3)
        {
            return Math.sign((p3.x - p1.x) * (-p2.y + p1.y) + (p3.y - p1.y) * (p2.x - p1.x))==-1;
        }

        function isInsideTriangle(a,b,c,p)
        {
            var area = 0.5*(-b.y * c.x + a.y * (-b.x + c.x) + a.x * (b.y - c.y) + b.x * c.y);
            var s = 1 / (2 * area) * (a.y * c.x - a.x * c.y + (c.y - a.y) * p.x + (a.x - c.x) * p.y);
            var t = 1 / (2 * area) * (a.x * b.y - a.y * b.x + (a.y - b.y) * p.x + (b.x - a.x) * p.y);
            return s >= 0 && t >= 0 && (s + t) <= 1;          
        }
			
        function mod(x,m)
        {
            return ((x%m)+m)%m;
        }

        function inside(p1,p2,p3)
        {
            // We test reflex vertices
            for(var i=0;i<points.length;i++){
                var pnt=points[i];
                if(pnt.convex!=true&&pnt.index!=p1.index&&pnt.index!=p2.index&&pnt.index!=p3.indexx){
                    if(isInsideTriangle(p1,p2,p3,pnt)) return true;
                }
            }
            return false;
        }

				function drawit()
				{	
						ctx.clearRect(0,0,900,900);
						
            ctx.font="20px Arial Narrow";
            
            // Prepare previous, next and current 
            for(var i=0;i<points.length;i++){
                points[i].index=i;
                points[i].prev=points[mod(i-1,points.length)];
                points[i].next=points[mod(i+1,points.length)];
                points[i].convex=isConvex(points[mod(i-1,points.length)],points[i],points[mod(i+1,points.length)]);
            }

            // Inside tests must happen after we prepare reflex/convex state for all points
            for(var i=0;i<points.length;i++){
                if(points[i].convex){
                      var state=false;
                      points[i].ear=inside(points[i].prev,points[i],points[i].next);
                  }else{
                      points[i].ear=false;
                  }            
            }

            for(var i=0;i<points.length;i++){
                var color;
                if(points[i].convex){
                    color="#bb8"
                }else{
                    color="#48b";
                }
                circ(points[i].x,points[i].y,color);
            }

            console.log(points);

            ctx.beginPath();
            for(var i=0;i<points.length;i++){
                ctx.moveTo(points[i].x*drawscale,points[i].y*drawscale);
                ctx.lineTo(points[(i+1)%points.length].x*drawscale,points[(i+1)%points.length].y*drawscale);
            }
            ctx.stroke();

   						// window.requestAnimationFrame(drawit);
				} 			
						
		</script>
</head>
<body onload="setup();">
 	<canvas id="myCanvas" onmousedown="mouseDown(event);" onmouseup="mouseUp(event);" onmousemove="mouseMove(event,this);" width="900" height="900" style="border:1px solid #000000;"></canvas> 
</body>
