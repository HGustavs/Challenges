<html>
<head>
		<style>
				body {margin: 0; height: 100%; overflow: hidden}
		</style>
		<script>

        //        (\ /)
        //        (. .)           
        //       c(")(")     âˆ´ 
        // Raycast Shadows
        // Codetrain 
        // https://www.youtube.com/watch?v=TOEi6T2mtHo&t=16s
        // https://ncase.me/sight-and-light/
        // Rays toward each segment end point

				var c;
        var xk=50;
        var yk=50;
        var xd=0;
        var yd=0;
			
				// Segments, Floor Clip Polygons, Shadow Areas 
				var segments=[
          {x1:8,y1:15,x2:198,y2:15},
          {x1:198,y1:15,x2:249,y2:61},
          {x1:249,y1:61,x2:286,y2:31},
          {x1:286,y1:31,x2:286,y2:22},
          {x1:286,y1:22,x2:360,y2:22},
          {x1:360,y1:22,x2:360,y2:58},
          {x1:360,y1:58,x2:296,y2:58},
          {x1:296,y1:58,x2:296,y2:84},
          {x1:296,y1:84,x2:334,y2:92},
          {x1:334,y1:92,x2:353,y2:246},
          {x1:353,y1:246,x2:264,y2:246},
          {x1:264,y1:246,x2:270,y2:162},
          {x1:270,y1:162,x2:287,y2:151},
          {x1:287,y1:151,x2:291,y2:123},
          {x1:291,y1:123,x2:215,y2:130},
          {x1:215,y1:130,x2:220,y2:151},
          {x1:220,y1:151,x2:232,y2:162},
          {x1:232,y1:162,x2:227,y2:246},
          {x1:227,y1:246,x2:172,y2:246},
          {x1:172,y1:246,x2:162,y2:134},
          {x1:162,y1:134,x2:117,y2:116},
          {x1:117,y1:116,x2:120,y2:156}, 
          {x1:120,y1:156,x2:64,y2:156},
          {x1:64,y1:156,x2:68,y2:110},
          {x1:68,y1:110,x2:8,y2:110},
          {x1:8,y1:110,x2:8,y2:15}
        ];
			
				// line intercect math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
				// Determine the intersection point of two line segments
				function intersect(p1,p2,p3,p4) {
					
						// Check if none of the lines are of length 0
						if ((p1.x === p2.x && p1.y === p2.y) || (p3.x === p4.x && p3.y === p4.y)) return false;

						denominator = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));
					
						// Lines are parallel
						if (denominator === 0) return false;

						let ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
						let ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

						// is the intersection along the segments
						if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;

						// Return a object with the x and y coordinates of the intersection
						let x = p1.x + ua * (p2.x - p1.x)
						let y = p1.y + ua * (p2.y - p1.y)
						
						return {x:x, y:y}
				}

				// Point s inside triangle p1,p2,p3
				function pointInTriangle(s, a, b, c)
				{
						as_x = s.x-a.x;
						as_y = s.y-a.y;

						s_ab = (b.x-a.x)*as_y-(b.y-a.y)*as_x > 0;

						if((c.x-a.x)*as_y-(c.y-a.y)*as_x > 0 == s_ab) return false;

						if((c.x-b.x)*(s.y-b.y)-(c.y-b.y)*(s.x-b.x) > 0 != s_ab) return false;

						return {x:s.x,y:s.y};
				}
			
				// Even Odd Rule Polyon Point Colision
				function pointInPolygon(point,segments)
				{
						// Never inside 	
						if(segments.length<3) return false;
					
						// Inside bounding box?
						if(!(point.x>=segments.p1.x&&point.x<=segments.p2.x&&point.y>=segments.p1.y&&point.y<=segments.p2.y)) return false;

						// Iterate over all segments and 
						var cnt=0;
						for(i=0;i<segments.length;i++){
								if(i==(segments.length-1)){
										p2=segments[0];
								}else{
										p2=segments[i+1];
								}
								p1=segments[i];
							
								// Swap if negative incline!
								if(p2.y<p1.y){
										var tmp=p2;
										p2=p1;
										p1=tmp;
								}

								if(point.y>=p1.y&&point.y<=p2.y){
										var dy=p2.y-p1.y;
										var dx=p2.x-p1.x;
										if((p1.x+((dx/dy)*(point.y-p1.y))<=point.x)) cnt++;
								}
						}
						
						if((cnt%2)==0) return false;
						return true;
				}
									
				function keydown(e)
				{
						if(e.keyCode==37){
								xd=-1;
						}else if(e.keyCode==39){
								xd=1;
						}else if(e.keyCode==38){
								yd=-1;
						}else if(e.keyCode==40){
								yd=1;
						}
				}
			
				function keyup(e)
				{
						if(e.keyCode==37||e.keyCode==39){
								xd=0;
						}else if(e.keyCode==38||e.keyCode==40){
								yd=0;
						}
				}		
			
				function setup()
				{
						var cc = document.getElementById("myCanvas");
				    c = cc.getContext("2d");
	
						setInterval(updatestate,20);
					
						drawit();
				}
											
				function updatestate()
				{
						xk+=xd;
						yk+=yd;
				}
			
				function drawit()
				{	
						c.clearRect(0,0,900,900);
						document.getElementById("mainsvg").innerHTML="";
					
						// Display player
						c.beginPath();
						c.arc(xk, yk, 5, 0, 2 * Math.PI);
						c.stroke(); 				

            c.strokeStyle="#000";
            c.beginPath();
            if(segments.length>0){
                c.moveTo(segments[0].x1,segments[0].y1);
                for(var segment of segments){
                    c.lineTo(segment.x2,segment.y2);
                }
            }
            c.stroke();

            c.strokeStyle="#f49";
            c.beginPath();
            if(segments.length>0){
                for(var segment of segments){
                    var dx=segment.x2-xk;
                    var dy=segment.y2-yk;
                    segment.ang=Math.atan2(dy,dx);

                    c.moveTo(xk,yk);
                    c.lineTo(xk+(Math.cos(segment.ang)*300),yk+(Math.sin(segment.ang)*300));
                }
            }
            c.stroke();


						window.requestAnimationFrame(drawit);
				}
			
		</script>
</head>
<body onload="setup();" onkeydown="keydown(event);" onkeyup="keyup(event);" >
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas>
	<svg style='border:1px dotted red;' height="900" width="900" id="mainsvg"></svg>
</body>
