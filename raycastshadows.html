<html>
<head>
		<style>
				body {margin: 0; height: 100%; overflow: hidden}
		</style>
		<script>

        //        (\ /)
        //        (. .)           
        //       c(")(")     âˆ´ 
        // Raycast Shadows
        // Codetrain 
        // https://www.youtube.com/watch?v=TOEi6T2mtHo&t=16s
        // https://ncase.me/sight-and-light/
        // https://www.redblobgames.com/articles/visibility/
        // Rays toward each segment end point

        // We need spatial hash to only test cells near ray
        // https://stackoverflow.com/questions/24679963/precise-subpixel-line-drawing-algorithm-rasterization-algorithm
        // https://stackoverflow.com/questions/4381269/line-rasterisation-cover-all-pixels-regardless-of-line-gradient

				var c;
        var mx,my,md;
        var mmx=300;
        var mmy=140;

        // Avatar variables
        var xk=320;
        var yk=140;
        var xd=0;
        var yd=0;

        // Benchmarking
        var intersectcount=0;

//------------------------------------=======############==========----------------------------------------
//                                 Spatial Hash Global Variables and Constants
//------------------------------------=======############==========----------------------------------------
	        
var hash=[];
var found=[];
const gridsize=20;                          // Spatial hash grid size
const gridhalf=gridsize/2;
const cwidth=900;
const cheight=900;
const gridx=Math.ceil(cwidth/gridsize);
const gridy=Math.floor(cheight/gridsize);

			
// Segments, Floor Clip Polygons, Shadow Areas 
var segments=[
  {x1:8,y1:15,x2:198,y2:15,id:0},
  {x1:198,y1:15,x2:249,y2:61,id:1},
  {x1:249,y1:61,x2:286,y2:31,id:2},
  {x1:286,y1:31,x2:286,y2:22,id:3},
  {x1:286,y1:22,x2:360,y2:22,id:4},
  {x1:360,y1:22,x2:360,y2:58,id:5},
  {x1:360,y1:58,x2:296,y2:58,id:6},
  {x1:296,y1:58,x2:296,y2:84,id:7},
  {x1:296,y1:84,x2:334,y2:92,id:8},
  {x1:334,y1:92,x2:353,y2:246,id:9},
  {x1:353,y1:246,x2:264,y2:246,id:10},
  {x1:264,y1:246,x2:270,y2:162,id:11},
  {x1:270,y1:162,x2:287,y2:151,id:12},
  {x1:287,y1:151,x2:291,y2:123,id:13},
  {x1:291,y1:123,x2:215,y2:130,id:14},
  {x1:215,y1:130,x2:220,y2:151,id:15},
  {x1:220,y1:151,x2:232,y2:162,id:16},
  {x1:232,y1:162,x2:227,y2:246,id:17},
  {x1:227,y1:246,x2:172,y2:246,id:18},
  {x1:172,y1:246,x2:162,y2:134,id:19},
  {x1:162,y1:134,x2:117,y2:116,id:20},
  {x1:117,y1:116,x2:120,y2:156,id:21}, 
  {x1:120,y1:156,x2:64,y2:156,id:22},
  {x1:64,y1:156,x2:68,y2:110,id:23},
  {x1:68,y1:110,x2:8,y2:110,id:24},
  {x1:8,y1:110,x2:8,y2:15,id:25}
];

// line intercect math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
// Determine the intersection point of two line segments
function intersect(p1,p2,p3,p4) {
  intersectcount++;
	
  // Check if none of the lines are of length 0
  if ((p1.x === p2.x && p1.y === p2.y) || (p3.x === p4.x && p3.y === p4.y)) return false;

  denominator = ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));

  // Lines are parallel
  if (denominator === 0) return false;

  let ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
  let ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

  // is the intersection along the segments
  if (ua < -0.01 || ua > 0.99 || ub < -0.01 || ub > 0.99) return false;

  // Return a object with the x and y coordinates of the intersection
  let x = p1.x + ua * (p2.x - p1.x)
  let y = p1.y + ua * (p2.y - p1.y)
  
  return {x:x, y:y}
}

function mouseMove(e,t)
{
		var rect = e.target.getBoundingClientRect();
    mx = e.clientX - rect.left; //x position within the element.
    my = e.clientY - rect.top;  //y position within the element

    if (md){
        mmx=mx;
        mmy=my;

        xk=mx;
        yk=my;
    }
 }

 function mouseDown(e)
 {
    md=true;
 }

function mouseUp(e)
{
  md=false;
}

function keydown(e)
{
		if(e.keyCode==37){
				xd=-1;
		}else if(e.keyCode==39){
				xd=1;
		}else if(e.keyCode==38){
				yd=-1;
		}else if(e.keyCode==40){
				yd=1;
		}
}

function keyup(e)
{
		if(e.keyCode==37||e.keyCode==39){
				xd=0;
		}else if(e.keyCode==38||e.keyCode==40){
				yd=0;
		}
}			

function setup()
{
		var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    for(var segment of segments){
        segment.x1*=2.5;
        segment.y1*=2.5;
        segment.x2*=2.5;
        segment.y2*=2.5;

    }
	
		drawit();
}
							
function updatestate()
{
		xk+=xd;
		yk+=yd;
}

function drawBox(x1,y1,w,h,opacity,fillcolor)
{
  c.fillStyle=fillcolor;
  c.globalAlpha=opacity;
  c.beginPath();
  c.fillRect(x1,y1,w,h);
  c.fill();  
  c.globalAlpha=1.0;
}

function drawLine(x1,y1,x2,y2,width,color)
{
    c.strokeStyle=color;
    c.globalAlpha=1.0;
    c.lineWidth=width;

    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();

    c.lineWidth=1.0;
}

function drawCirc(x1,y1,rad,width,color)
{
      c.strokeStyle=color;
      c.lineWidth=width;
      c.beginPath();
		  c.arc(x1, y1, rad, 0, 2 * Math.PI);
		  c.fill();
      c.lineWidth=1.0; 				
}

function visualizeHit(cxk,cyk,segment)
{
  if(cxk<0||cyk<0||cxk>=gridx||cyk>=gridy) return false;

  var index=(cyk*gridx)+cxk;
  if(hash[index]==null){
      hash[index]=[];
  }
  pushIfNotPresent(hash[index],segment);
}

function readHit(cxk,cyk,segment)
{
  if(cxk<0||cyk<0||cxk>=gridx||cyk>=gridy) return false;
  
  var index=(cyk*gridx)+cxk;
  if(hash[index]!=null){
      for(segment of hash[index]){
          pushIfNotPresent(found,segment);
      }
  }
  //drawBox(cxk*gridsize,cyk*gridsize,gridsize,gridsize,0.3,"#46f");
}

// Ray / Segment Spatial Hashing Bresenham Algorithm
// Itemcall function is called for each 'pixel' and is passed X and Y coordinate
function hashLine(x1,y1,x2,y2,segment,itemcall)
{
    // drawLine(x1,y1,x2,y2,2.0,"#c42");

    var dx=x2-x1;
    var dy=y2-y1;

    if(Math.abs(dx)>=Math.abs(dy)){
        var k=dy/dx;
        var m=y1-(k*x1);

        // Take care of left running lines
        if(x2<x1){
          tmp=x1;
          x1=x2;
          x2=tmp;
        }

        var cnt=Math.ceil(x2/gridsize)-Math.floor(x1/gridsize)+1;
        var xk=Math.floor(x1/gridsize);
        var oldyt=Math.floor(((k*xk*gridsize)+m)/gridsize);
        var ret=0;        
        for(var i=0;i<cnt;i++){
            yk=(k*(xk*gridsize)+m);
            yt=Math.floor(yk/gridsize);
            if(oldyt==yt){
                itemcall(xk,yt,segment);
            }else{
                itemcall(xk,yt,segment);
                itemcall(xk-1,yt,segment);
            }
            oldyt=yt;
            xk++;
        }
    }else{
        var k=dx/dy;
        var m=x1-(k*y1);

        // Take care of left running lines
        if(y2<y1){
          tmp=y1;
          y1=y2;
          y2=tmp;
        }

        var cnt=Math.ceil(y2/gridsize)-Math.floor(y1/gridsize)+1;
        var yk=Math.floor(y1/gridsize);
        var oldxt=Math.floor(((k*yk*gridsize)+m)/gridsize);
        var ret=0;
        for(var i=0;i<cnt;i++){
            xk=(k*(yk*gridsize)+m);
            xt=Math.floor(xk/gridsize);
            if(oldxt==xt){
                itemcall(xt,yk,segment);
            }else{
                itemcall(xt,yk,segment);
                itemcall(xt,yk-1,segment);
            }
            if(ret>0) break;
            oldxt=xt;
            yk++;
        }        
    }
}

// -------------------==============########==============-------------------
// Update of Spatial Hash - Find Which Segments that Intersect with Spatial Hash Cells
// We must make sure that we do not add same value to list again (to avoid double tests).
// Sparse Array?

function pushIfNotPresent(list,item)
{
    for(inner of list){
        if(inner.id==item.id) return false;
    }
    list.push(item);
}

function drawLine(x1,y1,x2,y2,width,color)
{
    c.strokeStyle=color;
    c.globalAlpha=1.0;
    c.lineWidth=width;

    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();

    c.lineWidth=1.0;

}

function drawit()
{	
    intersectcount=0;

		c.clearRect(0,0,900,900);
		document.getElementById("mainsvg").innerHTML="";

    // Draw spatial hash grid
    c.globalAlpha=0.5;
    c.strokeStyle="#080";
    c.beginPath();
    for(var i=0;i<cheight;i+=gridsize){
            c.moveTo(0,i);
            c.lineTo(cwidth,i);
    }
    for(var i=0;i<cwidth;i+=gridsize){
            c.moveTo(i,0);
            c.lineTo(i,cheight);
    }
    c.stroke();
     
    c.save();
    //c.scale(2.0,2.0);
	
		// Display player
		c.beginPath();
		c.arc(xk, yk, 5, 0, 2 * Math.PI);
		c.fill(); 				

    c.strokeStyle="#000";
    c.beginPath();
    if(segments.length>0){
        c.moveTo(segments[0].x1,segments[0].y1);
        for(var segment of segments){
            c.lineTo(segment.x2,segment.y2);
        }
    }
    c.stroke();

    // Update hash
    hash=[];
    for(segment of segments){
        hashLine(segment.x1,segment.y1,segment.x2,segment.y2,segment,visualizeHit);
    }

    c.restore();

    var rays=[];
    for(var segment of segments){
            var dx=segment.x2-xk;
            var dy=segment.y2-yk;
            segment.ang=Math.atan2(dy,dx);

            // Create ray from segment - push to list
            rays.push({x1:xk,y1:yk,x2:xk+(Math.cos(segment.ang-0.01)*900),y2:yk+(Math.sin(segment.ang-0.01)*900)});
            rays.push({x1:xk,y1:yk,x2:xk+(Math.cos(segment.ang+0.01)*900),y2:yk+(Math.sin(segment.ang+0.01)*900)});
    }

    var hits=[];
    for(var ray of rays){
            if(segment.id>-1){
                c.beginPath();
                c.moveTo(ray.x1,ray.y1);
                c.lineTo(ray.x2,ray.y2);
                c.stroke();

                // Intersect ray and collate closest intersection point
                found=[];
                hashLine(ray.x1,ray.y1,ray.x2,ray.y2,null,readHit);
                var currdst=10000000;
                var currx=0;
                var curry=0;
                for(var innersegment of found){

                    // drawLine(segment.x1,segment.y1,segment.x2,segment.y2,3.0,"#486");

                    var p1={x:ray.x1,y:ray.y1};
                    var p2={x:ray.x2,y:ray.y2};
                    var p3={x:innersegment.x1,y:innersegment.y1};
                    var p4={x:innersegment.x2,y:innersegment.y2};

                    var pnt=intersect(p1,p2,p3,p4);

                    let dx=pnt.x-xk;
                    let dy=pnt.y-yk;
                    let dsts=(dx*dx)+(dy*dy);

                    if(dsts<currdst){
                        currdst=dsts;
                        currx=pnt.x;
                        curry=pnt.y;
                    }
                }

                if(currdst<10000000){
                    hits.push({xk:currx,yk:curry,dst:currdst});
                }
            }    
    }

    // Visualize hits
    if(hits.length>0){
        //c.beginPath();
        //c.moveTo(hits[0].xk,hits[0].yk);
        for(hit of hits){
          //c.lineTo(hit.xk,hit.yk);
          drawCirc(hit.xk,hit.yk,8,2,"#48c");
        }
        //c.closePath();
        //c.fill();
    }

    c.font="20px Arial Narrow";
    c.fillText(intersectcount,50,25);

		window.requestAnimationFrame(drawit);
}
			
		</script>
</head>
<body onload="setup();" onkeydown="keydown(event);" onkeyup="keyup(event);" onmousedown="mouseDown(event)" onmouseup="mouseUp(event)" onmousemove="mouseMove(event)">
 	<canvas id="myCanvas" width="900" height="900" style="border:1px solid #000000;"></canvas>
	<svg style='border:1px dotted red;' height="900" width="900" id="mainsvg"></svg>
</body>
