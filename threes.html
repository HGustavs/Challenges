<html>
	<head>
	<script>

//------------------------------------=======############==========----------------------------------------
//                                 Canvas Slide Constants and Variables
//------------------------------------=======############==========----------------------------------------
		
// Challenge: Make animated threes-game with smallest amount of code

var c;
var arrpnt=[];
var delay=30;		

var xmax=1430;
var ymax=780;
var mx,my,mb;
	
function setupSlides()
{
		canvas = document.getElementById("mycanvas");
		c = canvas.getContext("2d");

		setTimeout(drawHead,delay);
}

// Draw a symbol with rounded corners
		
function drawSymbol(xk,yk,w,h,val,nval,perc)
{
		var r=8;
		c.beginPath();
		c.moveTo(xk+r,yk);
		c.lineTo(xk+w-r,yk);
		c.quadraticCurveTo(xk+w,yk,xk+w,yk+r);
		c.lineTo(xk+w,yk+h-r);
		c.quadraticCurveTo(xk+w,yk+h,xk+w-r,yk+h);
		c.lineTo(xk+r,yk+h);
		c.quadraticCurveTo(xk,yk+h,xk,yk+h-r);
		c.lineTo(xk,yk+r);
		c.quadraticCurveTo(xk,yk,xk+r,yk);
	
		if(val==0){
				c.stroke();		
		}else{
				c.textAlign = "center"; 
				c.textBaseline = "middle"; 
				c.font="30px Comic Sans MS";	
				if(val==1){
						c.fillStyle="#f28";
				}else if(val==2){
						c.fillStyle="#28f";
				}else{
						c.fillStyle="#ac2";				
				}
				c.fill();
			
				c.globalAlpha=perc;
				if(nval==3){
						c.fillStyle="#ac2";
						c.fill();
				}
				c.fillStyle="#000";
				c.fillText(nval,xk+(w*0.5),yk+(h*0.5));	
				
				c.globalAlpha=1.0-perc;
				c.fillText(val,xk+(w*0.5),yk+(h*0.5));

				c.globalAlpha=1.0;
		}
}
		
document.onkeydown = checkKey;

function checkKey(e) {
    if (e.keyCode == '38') {
				progressGrid(0,-1);
		}else if (e.keyCode == '40') {
				progressGrid(0,1);
    }else if (e.keyCode == '37') {
				progressGrid(-1,0);
    }else if (e.keyCode == '39') {
				progressGrid(1,0);
    }
}		
		
var perc=1.0;
var upd=true;
var gamegrid=[];
var gridX=7;
var gridY=7;
var anim=[];

for(var i=0;i<(gridX*gridY);i++){
		gamegrid[i]=0;
}

gamegrid[15]=96;		
gamegrid[16]=1;
gamegrid[17]=2;
gamegrid[18]=3;
gamegrid[10]=6;		
gamegrid[25]=12;
gamegrid[32]=24;
gamegrid[31]=48;

//----------------------------------------------------------------------------------
// shift - Shift function does not know which tiles we are shifting
//----------------------------------------------------------------------------------	

		function shift(topos,frompos,fromx,fromy,tox,toy)
{

		if((gamegrid[topos]==0)&&(gamegrid[frompos]!=0)){
				// Empty -> Something
				anim.push({fx:fromx,fy:fromy,tx:tox,ty:toy,ns:gamegrid[frompos],ne:gamegrid[frompos]});
				gamegrid[topos]=gamegrid[frompos];
				gamegrid[frompos]=0;
		}else if(((gamegrid[topos]==1)&&(gamegrid[frompos]==2))||((gamegrid[topos]==2)&&(gamegrid[frompos]==1))){
				// 1 -> 2 || 2 -> 1 (push one static and one moving animation to three)
				anim.push({fx:tox,fy:toy,tx:tox,ty:toy,ns:gamegrid[topos],ne:gamegrid[topos]});			
				anim.push({fx:fromx,fy:fromy,tx:tox,ty:toy,ns:gamegrid[frompos],ne:3});
				gamegrid[topos]=3;
				gamegrid[frompos]=0;
		}else if((gamegrid[topos]==gamegrid[frompos])&&(gamegrid[topos]!=2)&&(gamegrid[topos]!=1)&&(gamegrid[topos]!=0)){
				// something -> same something (double)
				anim.push({fx:tox,fy:toy,tx:tox,ty:toy,ns:gamegrid[topos],ne:gamegrid[topos]});						
				anim.push({fx:fromx,fy:fromy,tx:tox,ty:toy,ns:gamegrid[frompos],ne:gamegrid[frompos]*2});	
				gamegrid[topos]=gamegrid[topos]*2;
				gamegrid[frompos]=0;		
		}else if(gamegrid[topos]!=0){
				//console.log(gamegrid[frompos],gamegrid[topos]);
				// From position not moving but not empty (animate only)
				anim.push({fx:tox,fy:toy,tx:tox,ty:toy,ns:gamegrid[topos],ne:gamegrid[topos]});
		}
}
		
//----------------------------------------------------------------------------------
// animate - Animate tile positions
//----------------------------------------------------------------------------------	

function animate(perc)
{
		// Draw Grid
		for(var i=0;i<gridX;i++){
				for(var j=0;j<gridY;j++){
						drawSymbol(70+(i*68),70+(j*68),64,64,0);
				}
		}		
	
		// Draw animating tiles
		for(var i=0;i<anim.length;i++){
				item=anim[i];
				xk=item.fx+((item.tx-item.fx)*perc);
				yk=item.fy+((item.ty-item.fy)*perc);
			
				drawSymbol(70+(xk*68),70+(yk*68),64,64,item.ns,item.ne,perc);
		}
}
		
//----------------------------------------------------------------------------------
// processGrid - Update grid (tetris physics)
//----------------------------------------------------------------------------------	
		
function progressGrid(mox,moy)
{
		perc=0.0;
		anim=[];
		if(mox==1){
				// Move right! - progress from top to bottom, and from right to left
				for(var j=1;j<(gridY-1);j++){
						for(var i=(gridX-2);i>=1;i--){
								shift((j*gridX)+i,(j*gridX)+i-1,i-1,j,i,j);
						}
				}
		}else if(mox==-1){
				// Move left! - progress from top to bottom, and from left to right
				for(var j=1;j<(gridY-1);j++){
						for(var i=1;i<=(gridX-1);i++){
								shift((j*gridX)+i,(j*gridX)+i+1,i+1,j,i,j);
						}
				}			
		}else if(moy==1){
				alert("down!");
				// Move down
				for(var j=(gridY-2);j>=1;j--){
						for(var i=(gridX-2);i>=1;i--){
								shift((j*gridX)+i,(j*gridX)+i-gridY,i,j-1,i,j);
						}
				}
		}else if(moy==-1){
				// Move up
				for(var j=1;j<(gridY-1);j++){
						for(var i=1;i<=(gridX-1);i++){
								shift((j*gridX)+i,(j*gridX)+i+gridY,i,j+1,i,j);
						}
				}
		}
}
				
//----------------------------------------------------------------------------------
// drawHead - Clear screen and keep drawing
//----------------------------------------------------------------------------------
		
function drawHead()
{
		if(perc<1.0||upd==true) c.clearRect(0,0,xmax,ymax);
	
		// Draw game grid
		if(perc==1.0&&upd==true){
				upd=false;
				for(var i=0;i<gridX;i++){
						for(var j=0;j<gridY;j++){
								drawSymbol(70+(i*68),70+(j*68),64,64,gamegrid[(j*gridY)+i],gamegrid[(j*gridY)+i],1.0);
						}
				}		
	
		}else if(perc<1.0){
				animate(perc);
		}else{
		
		}
	
		perc+=0.01;
		if(perc>1.0) perc=1.0;
		
		window.requestAnimationFrame(drawHead);
	
}
		
function mousemove(e)
{
		var rect = e.target.getBoundingClientRect();
		mx = e.clientX - rect.left; //x position within the element.
		my = e.clientY - rect.top;  //y position within the element.				
}

	</script>
	</head>
	<body onload="setupSlides();">
	<canvas id='mycanvas' width=1430 height=780 style='border:1px solid red;' onmousemove='mousemove(event);' ></canvas>	
	</body>

</html>