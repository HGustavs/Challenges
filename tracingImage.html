<!DOCTYPE html>
<html>
<head>
    <style>
        #wrapper{
            display:grid;
            grid-template-areas: "main tools";
        }

        #myCanvas{
            grid-area:main;
        }

        #toolsCanvas{
            grid-area:tools;
        }
        
    </style>
    <script>//document.write("<script type='text/javascript' src='helperFunction/hexcolors.js?t=" + Date.now() + "'><\/script>");</script>
		<script>

// https://stackoverflow.com/questions/23090019/fastest-formula-to-get-hue-from-rgb
// https://gowtham000.hashnode.dev/median-cut-a-popular-colour-quantization-strategy
// https://web.archive.org/web/20160418231732/http://www.cs.berkeley.edu/~dcoetzee/downloads/scolorq/#sampleimages
// https://muthu.co/reducing-the-number-of-colors-of-an-image-using-median-cut-algorithm/
// https://stackoverflow.com/questions/21483999/using-atan2-to-find-angle-between-two-vectors

var mx=40,my=40;

var c;
var world = new Image();
var width=2048;
var height=1000;
var ystart=0;
var xstart=0;
var xend=width-1;
var yend=height-1;
var scale=1;
var xoffs=0;
var yoffs=0;
var fontsize=13;

var segments=[];
var paths=[];
var pointHash=[];

// CrossProduct pasted into vector angle function
function CrossProduct(v1x,v1y,v2x,v2y)
{
    return (v1x*v2y) - (v1y*v2x);
}

// DotProduct pasted into vector angle function
function DotProduct(v1x,v1y,v2x,v2y)
{
  return (v1x*v2x) + (v1y*v2y);
}

// VectAngle angle between two vectors
function vectAngle(v1x,v1y,v2x,v2y)
{
    return Math.floor((Math.atan2((v1x*v2y)-(v1y*v2x),(v1x*v2x)+(v1y*v2y))/(2.0*Math.PI))*360);
}

function zetup()
{
    var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    world.src = 'data/Equirectangular2.png';
    world.onload = function () {
        updatestate();
    };    
}

function randomColor()
{
    var R=Math.floor(Math.random()*255);
    var G=Math.floor(Math.random()*255);
    var B=Math.floor(Math.random()*255);

    return "RGB("+R+","+G+","+B+")";
}

// We make a bit number if byte value is over treshold
function imgToBits(imgdata,px,py,comp,treshold)
{
    var num=0;
    var index=((py*width)+px)*4;
    var yadd=width*4;
    if(imgdata[index+comp]>treshold) num+=1;
    if(imgdata[index+comp+4]>treshold) num+=2;
    if(imgdata[index+comp+yadd]>treshold) num+=4;
    if(imgdata[index+comp+yadd+4]>treshold) num+=8;
    return num;
}

function makesegment(px1,py1,px2,py2)
{
    var segment={id:segments.length,x1:px1,y1:py1,x2:px2,y2:py2,visited:false};
    addHash(px1,segment);
    addHash(px2,segment);
    segments.push(segment);
}

// We do not add duplicates of same segment to cache
function addHash(coord,item)
{
    for(pnt of pointHash[coord]){
        if(pnt.id==item.id) return false;
    }
    pointHash[coord].push(item);
}

function collatepoints(xk,yk)
{
    let path=[];
    var currx=xk;
    var curry=yk;
    do{
        var foundcnt=0;
        var founditem=null;
        var items=[];

        for(point of pointHash[currx]){
            if(((point.x1==currx&&point.y1==curry)||(point.x2==currx&&point.y2==curry))){
                if(point.visited==false){
                    foundcnt++;
                    founditem=point;
                }
            }
        }

        if(foundcnt==0){
            // Match not found i.e. end of path or error
            //console.log("NF",currx,curry);
        }else if(foundcnt>1){
            // Branching path i.e. split points
            //console.log("BR ",currx,curry,items);
        }else{
            path.push(founditem);
            founditem.visited=true;
            // Starting point of segment found or ending point of segment found
            if(founditem.y1==curry&&founditem.x1==currx){
                currx=founditem.x2;
                curry=founditem.y2;
            }else{
                currx=founditem.x1;
                curry=founditem.y1;                  
            }
        }
    }while(foundcnt==1);

    return path;
}

function findmatch(paths)
{
    var mindist=500000;
    var retval=false;
    for(var i=0;i<paths.length;i++){
        var path=paths[i];
        for(var j=0;j<paths.length;j++){
            var otherpath=paths[j];
            if(i!=j&&path.length>10&&otherpath.length>10){
                // This is a normal segment - start of path is close to end of otherpath
                var dx=path[0].x1-otherpath[otherpath.length-1].x2;
                var dy=path[0].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:0,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }
                // This is a reverse segment type A - start of path is close to start of otherpath, we must reverse otherpath
                var dx=path[0].x1-otherpath[0].x2;
                var dy=path[0].y1-otherpath[0].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:1,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[0].x2,p2y:otherpath[0].y2};
                }
                // This is a reverse segment type B - end of path is close to end of otherpath, we must reverse path
                var dx=path[path.length-1].x1-otherpath[otherpath.length-1].x2;
                var dy=path[path.length-1].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:-1,path:i,other:j,dist:dist,p1x:path[path.length-1].x1,p1y:path[path.length-1].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }                                  
            }
        }
    }
    if(retval!=false){
        if(retval.dist>200) return false;
    }
    return retval;
}

function drawPath(path,xoffs,yoffs,scale,fillstate)
{
    // Draw each path
    c.strokeStyle=path.color;
    c.fillStyle=path.color;            
    c.beginPath();
    c.moveTo(xoffs+(path[0].x1*scale),yoffs+(path[0].y1*scale));
    for(segment of path){
        c.lineTo(xoffs+(segment.x2*scale),yoffs+(segment.y2*scale));    
    }
    if(fillstate){
        c.fill();
    }else{
        c.stroke();        
    }
}

function drawBoundingBox(path,xoffs,yoffs,scale)
{
    c.setLineDash([2, 2]);
    c.strokeStyle="#888";
    c.beginPath();

    c.moveTo(xoffs+(path.minx*scale),yoffs+(path.miny*scale));
    c.lineTo(xoffs+(path.maxx*scale),yoffs+(path.miny*scale));
    c.moveTo(xoffs+(path.minx*scale),yoffs+(path.maxy*scale));
    c.lineTo(xoffs+(path.maxx*scale),yoffs+(path.maxy*scale));
    c.moveTo(xoffs+(path.minx*scale),yoffs+(path.miny*scale));
    c.lineTo(xoffs+(path.minx*scale),yoffs+(path.maxy*scale));
    c.moveTo(xoffs+(path.maxx*scale),yoffs+(path.miny*scale));
    c.lineTo(xoffs+(path.maxx*scale),yoffs+(path.maxy*scale));

    c.stroke();
    c.setLineDash([]);

    c.fillStyle="#000";
    c.font = (fontsize*scale)+"px Arial Narrow";

    c.fillText(path.no,xoffs+(path.minx*scale), yoffs+(path.miny*scale));
    c.fillText(path.length,xoffs+(path.minx*scale), yoffs+(path.miny*scale)+(fontsize*scale));

}

// Give three points and test angle between those points including drawing of points
function testangle(cp,p1,p2)
{
    // We make one forward vector and one rear vector in order to get a "zero centered" angle from formula
    var v1x=cp.x1-p1.x1;
    var v1y=cp.y1-p1.y1;
    var v2x=p2.x1-cp.x1;
    var v2y=p2.y1-cp.y1;  
    return Math.floor((Math.atan2((v1x*v2y)-(v1y*v2x),(v1x*v2x)+(v1y*v2y))/(2.0*Math.PI))*360);
}

function pointAngle(path,index,stride)
{
    var p1=path[mod(index-stride,path.length)];
    var p2=path[mod(index+stride,path.length)];
    var cp=path[index];

    /*
    c.strokeStyle="#080";
    c.beginPath();
    c.moveTo(cp.x1,cp.y1);
    c.lineTo(p1.x1,p1.y1);
    c.moveTo(cp.x1,cp.y1);
    c.lineTo(p2.x1,p2.y1);
    c.stroke();  
    */

    return testangle(cp,p1,p2);
}

function mod(val,n)
{
    return ((val % n) + n) % n;
}

function updatestate()
{
    
    // Empty cache
    for(var i=0;i<width;i++){
        pointHash[i]=[];
    }
    // World to the left and tiles to the right

//    toolcanvas.drawImage(tiles,0,0);
    c.drawImage(world,0,0);

    c.fillStyle="#000";
    //c.fillRect(500,100,4,4);

    var mapdata=c.getImageData(0,0,width,height).data;

    var bitvalues=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    for(var py=ystart;py<yend;py++){
        for(var px=xstart;px<xend;px++){
            var bitvalue=(imgToBits(mapdata,px,py,2,80));
            bitvalues[bitvalue]++;
            if(bitvalue==3) makesegment(px,py,px+1,py);     // Straight Horizontal Top
            if(bitvalue==5) makesegment(px,py,px,py+1);     // Straight Vertical Left
            if(bitvalue==6||bitvalue==7||bitvalue==14) makesegment(px,py+1,px+1,py);
            if(bitvalue==9||bitvalue==11||bitvalue==13) makesegment(px,py,px+1,py+1);          
            if(bitvalue==10) makesegment(px+1,py,px+1,py+1);    // Straight Vertical Right
            if(bitvalue==12) makesegment(px,py+1,px+1,py+1);    // Straight Horizontal Bottom
        }
    }

    c.clearRect(0,0,2050,1002);

    var paths=[];

    // We want a fast algorithm for joining segments
    for(segment of segments){
        // Visit all unvisited segments 
        if(segment.visited==false){
            // Start new path and assign current coordinates that we are matching
            segment.visited=true;
            var path=collatepoints(segment.x1,segment.y1);
            var after=collatepoints(segment.x2,segment.y2);
            path.reverse();
            path.push(segment);
            path=path.concat(after);

            path.color=randomColor();            

            // Path is ready
            paths.push(path);
        }
    }

    var finishedpaths=[];

    // Remove looping paths (this includes small loops and segments)
    for(var i=paths.length-1;i>0;i--){
        var path=paths[i];
            if(path[0].x1==path[path.length-1].x2&&path[0].y1==path[path.length-1].y2){
                var finishedpath=paths.splice(i,1);
                finishedpaths.push(finishedpath);
            }else if(path.length<10){
                paths.splice(i,1);
            }
    }

    // Find corresponding segments that end in the same place as this segment starts or vice versa
    for(var removalcnt=0;removalcnt<path.length;removalcnt++){
        var matches=findmatch(paths);
        if(matches!=false){
            if(matches.kind==1){
                // Reverse other
                paths[matches.other].reverse();
            }else if(matches.kind==-1){
                // Reverse path
                paths[matches.path].reverse();
            }  
            
            var gurk=paths[matches.other].concat(paths[matches.path]);
            if(matches.other>matches.path){
                paths.splice(matches.other,1);
                paths.splice(matches.path,1);
            }else{
                paths.splice(matches.path,1);
                paths.splice(matches.other,1);        
            }
            //gurk.color="#f45"; //randomColor();
            gurk.color=randomColor();
            paths.push(gurk);
        }else{
            break;
        }
    }

    // Add finished paths back to main path object
    for(path of finishedpaths)
    {
        paths.push(path[0]);
    }

    // Prepare path data for each path
    for(path of paths){
        var minx=500000;
        var maxx=-500000;
        var miny=500000;
        var maxy=-500000;
        for(segment of path){
            minx=Math.min(minx,Math.min(segment.x1,segment.x2));
            maxx=Math.max(maxx,Math.max(segment.x1,segment.x2));
            miny=Math.min(miny,Math.min(segment.y1,segment.y2));
            maxy=Math.max(maxy,Math.max(segment.y1,segment.y2));
        }
        path.minx=minx;
        path.miny=miny;
        path.maxx=maxx;
        path.maxy=maxy;
        path.area=(maxx-minx)*(maxy-miny);
    }

    // We remove all paths with an area smaller than treshold area or smaller than x points
    for(var i=paths.length-1;i>0;i--){
        var path=paths[i];
            if(path.length<10||path.area<400){
                paths.splice(i,1);
            }
    }

    // Number remaining paths
    var ct=0;
    for(path of paths){
        path.no=ct++;
    }

    // Idea is to turn the spline into a bezier curve

    // Draw Bounding Boxes and number paths
    for(path of paths){
        drawPath(path,xoffs,yoffs,scale,false);
        drawBoundingBox(path,xoffs,yoffs,scale);
    }

    var lastindex=0;
    for(var index=0;index<paths[13].length;index+=10){
      //var index=Math.round(Math.random()*paths[13].length);
      console.log(Math.abs(index-lastindex));
      if((Math.abs(pointAngle(paths[13],index,15))>30)||(Math.abs(index-lastindex)>50)){
          c.fillStyle="#000";
          c.beginPath();
          c.arc(paths[13][index].x1,paths[13][index].y1, 5, 0, 2 * Math.PI);
          c.fill();
          lastindex=index;
      }else{
          c.strokeStyle="#000";
          c.beginPath();
          c.arc(paths[13][index].x1,paths[13][index].y1, 5, 0, 2 * Math.PI);
          //c.stroke();
      }
    }
}

function mouseMove(e)
{
    var rect = document.getElementById(e.target.id).getBoundingClientRect();

    mx=(e.clientX-rect.left);
    my=(e.clientY-rect.top);

//    updatestate();
}

		</script>
</head>
<body onload="zetup();">

<!--  <button onclick="Export();">Export</button>-->
  <div id="wrapper">
 	<canvas id="myCanvas" width="4096" height="2048" style="border:1px solid #000000;" onmousemove="mouseMove(event);" ></canvas> 
  </div>
</body>