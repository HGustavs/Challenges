<!DOCTYPE html>
<html>
<head>
    <style>
        #wrapper{
            display:grid;
            grid-template-areas: "main tools";
        }

        #myCanvas{
            grid-area:main;
        }

        #toolsCanvas{
            grid-area:tools;
        }
        
    </style>
    <script>//document.write("<script type='text/javascript' src='helperFunction/hexcolors.js?t=" + Date.now() + "'><\/script>");</script>
		<script>
var c;
var mx,my,mb=0;
var world = new Image();

function zetup()
{
    var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    world.src = 'data/Equirectangular2.png';
    world.onload = function () {
        updatestate();
    };    
}

// We make a bit number if byte value is over treshold
function imgToBits(imgdata,px,py,comp,treshold)
{
    var num=0;
    var index=((py*width)+px)*4;
    var yadd=width*4;
    if(imgdata[index+comp]>treshold) num+=1;
    if(imgdata[index+comp+4]>treshold) num+=2;
    if(imgdata[index+comp+yadd]>treshold) num+=4;
    if(imgdata[index+comp+yadd+4]>treshold) num+=8;
    return num;
}

var width=2048;
var height=1000;

var segments=[];
var paths=[];
var pointHash=[];

function makesegment(px1,py1,px2,py2)
{
    var segment={id:segments.length,x1:px1,y1:py1,x2:px2,y2:py2,visited:false};
    addHash(px1,segment);
    addHash(px2,segment);
    segments.push(segment);
}

// We do not add duplicates of same segment to cache
function addHash(coord,item)
{
    for(pnt of pointHash[coord]){
        if(pnt.id==item.id) return false;
    }
    pointHash[coord].push(item);
}

function collatepoints(xk,yk)
{
    let path=[];
    var currx=xk;
    var curry=yk;
    do{
        var foundcnt=0;
        var founditem=null;
        var items=[];

        for(point of pointHash[currx]){
            if(((point.x1==currx&&point.y1==curry)||(point.x2==currx&&point.y2==curry))){
                if(point.visited==false){
                    foundcnt++;
                    founditem=point;
                }
            }
        }

        if(foundcnt==0){
            // Match not found i.e. end of path or error
            //console.log("NF",currx,curry);
        }else if(foundcnt>1){
            // Branching path i.e. split points
            //console.log("BR ",currx,curry,items);
        }else{
            path.push(founditem);
            founditem.visited=true;
            // Starting point of segment found or ending point of segment found
            if(founditem.y1==curry&&founditem.x1==currx){
                currx=founditem.x2;
                curry=founditem.y2;
            }else{
                currx=founditem.x1;
                curry=founditem.y1;                  
            }
        }
    }while(foundcnt==1);

    return path;
}

function randomColor()
{
    var R=Math.floor(Math.random()*255);
    var G=Math.floor(Math.random()*255);
    var B=Math.floor(Math.random()*255);

    return "RGB("+R+","+G+","+B+")";
}

function findmatch(paths)
{
    var mindist=500000;
    var retval=false;
    for(var i=0;i<paths.length;i++){
        var path=paths[i];
        for(var j=0;j<paths.length;j++){
            var otherpath=paths[j];
            if(i!=j&&path.length>10&&otherpath.length>10){
                // This is a normal segment - start of path is close to end of otherpath
                var dx=path[0].x1-otherpath[otherpath.length-1].x2;
                var dy=path[0].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:0,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }
                // This is a reverse segment type A - start of path is close to start of otherpath, we must reverse otherpath
                var dx=path[0].x1-otherpath[0].x2;
                var dy=path[0].y1-otherpath[0].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:1,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[0].x2,p2y:otherpath[0].y2};
                }
                // This is a reverse segment type B - end of path is close to end of otherpath, we must reverse path
                var dx=path[path.length-1].x1-otherpath[otherpath.length-1].x2;
                var dy=path[path.length-1].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:-1,path:i,other:j,dist:dist,p1x:path[path.length-1].x1,p1y:path[path.length-1].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }                                  
            }
        }
    }
    if(retval!=false){
        if(retval.dist>200) return false;
    }
    return retval;
}

function updatestate()
{
    // Empty cache
    for(var i=0;i<width;i++){
        pointHash[i]=[];
    }
    // World to the left and tiles to the right

//    toolcanvas.drawImage(tiles,0,0);
    c.drawImage(world,0,0);

    c.fillStyle="#000";
    //c.fillRect(500,100,4,4);

    var mapdata=c.getImageData(0,0,width,height).data;

    var ystart=0;
    var xstart=0;
    var xend=width-1;
    var yend=height-1;
    var scale=1;
    var xoffs=0;

    var bitvalues=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    for(var py=ystart;py<yend;py++){
        for(var px=xstart;px<xend;px++){
            var bitvalue=(imgToBits(mapdata,px,py,2,80));
            bitvalues[bitvalue]++;
            if(bitvalue==3) makesegment(px,py,px+1,py);     // Straight Horizontal Top
            if(bitvalue==5) makesegment(px,py,px,py+1);     // Straight Vertical Left
            if(bitvalue==6||bitvalue==7||bitvalue==14) makesegment(px,py+1,px+1,py);
            if(bitvalue==9||bitvalue==11||bitvalue==13) makesegment(px,py,px+1,py+1);          
            if(bitvalue==10) makesegment(px+1,py,px+1,py+1);    // Straight Vertical Right
            if(bitvalue==12) makesegment(px,py+1,px+1,py+1);    // Straight Horizontal Bottom
        }
    }

    c.clearRect(0,0,2050,1002);

    var paths=[];

    // We want a fast algorithm for joining segments
    for(segment of segments){
        // Visit all unvisited segments 
        if(segment.visited==false){
            // Start new path and assign current coordinates that we are matching
            segment.visited=true;
            var path=collatepoints(segment.x1,segment.y1);
            var after=collatepoints(segment.x2,segment.y2);
            path.reverse();
            path.push(segment);
            path=path.concat(after);

            path.color=randomColor();            

            // Path is ready
            paths.push(path);
        }
    }    

    // Try to make loops black

    var finishedpaths=[];

    // Remove looping paths
    for(var i=paths.length-1;i>0;i--){
        var path=paths[i];
            if(path[0].x1==path[path.length-1].x2&&path[0].y1==path[path.length-1].y2){
                var finishedpath=paths.splice(i,1);
                finishedpaths.push(finishedpath);
            }else if(path.length<10){
                paths.splice(i,1);
            }
    }

    // Find corresponding segments that end in the same place as this segment starts or vice versa
    for(var removalcnt=0;removalcnt<path.length;removalcnt++){
        var matches=findmatch(paths);
        if(matches!=false){
            c.strokeStyle="#2f2";
            c.beginPath();                
            c.moveTo(matches.p1x,matches.p1y);
            c.lineTo(matches.p2x,matches.p2y);    
            c.stroke();

            if(matches.kind==1){
                // Reverse other
                paths[matches.other].reverse();
            }else if(matches.kind==-1){
                // Reverse path
                paths[matches.path].reverse();
            }  
            
            c.strokeStyle="#f22";
            c.beginPath();
            for(segment of paths[matches.other]){
                c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
                c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
            }
            c.stroke();  

            c.strokeStyle="#22f";
            c.beginPath();
            for(segment of paths[matches.path]){
                c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
                c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
            }
            c.stroke();  

            var gurk=paths[matches.other].concat(paths[matches.path]);
            if(matches.other>matches.path){
                paths.splice(matches.other,1);
                paths.splice(matches.path,1);
            }else{
                paths.splice(matches.path,1);
                paths.splice(matches.other,1);        
            }
            //gurk.color="#f45"; //randomColor();
            gurk.color=randomColor();
            paths.push(gurk);
        }else{
            break;
        }
    }

    // Draw each path
    for(path of paths){
        console.log(path.length);
        if(path.length>10){
            c.strokeStyle=path.color;
            c.beginPath();
            for(segment of path){
                c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
                c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
            }
            c.stroke();            
        }
    }
    console.log(paths);

}

		</script>
</head>
<body onload="zetup();">

<!--  <button onclick="Export();">Export</button>-->
  <div id="wrapper">
 	<canvas id="myCanvas" width="4096" height="2048" style="border:1px solid #000000;"></canvas> 
  </div>
</body>