<!DOCTYPE html>
<html>
<head>
    <style>
        #wrapper{
            display:grid;
            grid-template-areas: "main tools";
        }

        #myCanvas{
            grid-area:main;
        }

        #toolsCanvas{
            grid-area:tools;
        }
        
    </style>
    <script>//document.write("<script type='text/javascript' src='helperFunction/hexcolors.js?t=" + Date.now() + "'><\/script>");</script>
		<script>

// https://stackoverflow.com/questions/23090019/fastest-formula-to-get-hue-from-rgb
// https://gowtham000.hashnode.dev/median-cut-a-popular-colour-quantization-strategy
// https://web.archive.org/web/20160418231732/http://www.cs.berkeley.edu/~dcoetzee/downloads/scolorq/#sampleimages
// https://muthu.co/reducing-the-number-of-colors-of-an-image-using-median-cut-algorithm/
// https://stackoverflow.com/questions/21483999/using-atan2-to-find-angle-between-two-vectors


var c;
var world = new Image();

// CrossProduct pasted into vector angle function
function CrossProduct(v1x,v1y,v2x,v2y)
{
    return (v1x*v2y) - (v1y*v2x);
}

// DotProduct pasted into vector angle function
function DotProduct(v1x,v1y,v2x,v2y)
{
  return (v1x*v2x) + (v1y*v2y);
}

function vectAngle(v1x,v1y,v2x,v2y)
{
    return Math.atan2((v1x*v2y)-(v1y*v2x),(v1x*v2x)+(v1y*v2y));
}

function zetup()
{
    var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    world.src = 'data/Equirectangular2.png';
    world.onload = function () {
        updatestate();
    };    
}

// We make a bit number if byte value is over treshold
function imgToBits(imgdata,px,py,comp,treshold)
{
    var num=0;
    var index=((py*width)+px)*4;
    var yadd=width*4;
    if(imgdata[index+comp]>treshold) num+=1;
    if(imgdata[index+comp+4]>treshold) num+=2;
    if(imgdata[index+comp+yadd]>treshold) num+=4;
    if(imgdata[index+comp+yadd+4]>treshold) num+=8;
    return num;
}

var width=2048;
var height=1000;

var segments=[];
var paths=[];
var pointHash=[];

function makesegment(px1,py1,px2,py2)
{
    var segment={id:segments.length,x1:px1,y1:py1,x2:px2,y2:py2,visited:false};
    addHash(px1,segment);
    addHash(px2,segment);
    segments.push(segment);
}

// We do not add duplicates of same segment to cache
function addHash(coord,item)
{
    for(pnt of pointHash[coord]){
        if(pnt.id==item.id) return false;
    }
    pointHash[coord].push(item);
}

function collatepoints(xk,yk)
{
    let path=[];
    var currx=xk;
    var curry=yk;
    do{
        var foundcnt=0;
        var founditem=null;
        var items=[];

        for(point of pointHash[currx]){
            if(((point.x1==currx&&point.y1==curry)||(point.x2==currx&&point.y2==curry))){
                if(point.visited==false){
                    foundcnt++;
                    founditem=point;
                }
            }
        }

        if(foundcnt==0){
            // Match not found i.e. end of path or error
            //console.log("NF",currx,curry);
        }else if(foundcnt>1){
            // Branching path i.e. split points
            //console.log("BR ",currx,curry,items);
        }else{
            path.push(founditem);
            founditem.visited=true;
            // Starting point of segment found or ending point of segment found
            if(founditem.y1==curry&&founditem.x1==currx){
                currx=founditem.x2;
                curry=founditem.y2;
            }else{
                currx=founditem.x1;
                curry=founditem.y1;                  
            }
        }
    }while(foundcnt==1);

    return path;
}

function randomColor()
{
    var R=Math.floor(Math.random()*255);
    var G=Math.floor(Math.random()*255);
    var B=Math.floor(Math.random()*255);

    return "RGB("+R+","+G+","+B+")";
}

function findmatch(paths)
{
    var mindist=500000;
    var retval=false;
    for(var i=0;i<paths.length;i++){
        var path=paths[i];
        for(var j=0;j<paths.length;j++){
            var otherpath=paths[j];
            if(i!=j&&path.length>10&&otherpath.length>10){
                // This is a normal segment - start of path is close to end of otherpath
                var dx=path[0].x1-otherpath[otherpath.length-1].x2;
                var dy=path[0].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:0,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }
                // This is a reverse segment type A - start of path is close to start of otherpath, we must reverse otherpath
                var dx=path[0].x1-otherpath[0].x2;
                var dy=path[0].y1-otherpath[0].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:1,path:i,other:j,dist:dist,p1x:path[0].x1,p1y:path[0].y1,p2x:otherpath[0].x2,p2y:otherpath[0].y2};
                }
                // This is a reverse segment type B - end of path is close to end of otherpath, we must reverse path
                var dx=path[path.length-1].x1-otherpath[otherpath.length-1].x2;
                var dy=path[path.length-1].y1-otherpath[otherpath.length-1].y2;
                var dist=(dx*dx)+(dy*dy);
                if((dist<mindist)){
                    mindist=dist;
                    retval={kind:-1,path:i,other:j,dist:dist,p1x:path[path.length-1].x1,p1y:path[path.length-1].y1,p2x:otherpath[otherpath.length-1].x2,p2y:otherpath[otherpath.length-1].y2};
                }                                  
            }
        }
    }
    if(retval!=false){
        if(retval.dist>200) return false;
    }
    return retval;
}

function drawPaths(paths,xoffs,yoffs,xstart,ystart,scale)
{
    // Draw each path
    for(path of paths){           
        c.beginPath();
        for(segment of path){
            c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
            c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
        }
        c.stroke();        
    }
}

function updatestate()
{

  c.clearRect(0,0,1000,1000);

  var cx=200,cy=200;
  var lx=240,ly=40;
  
  c.beginPath();
  c.moveTo(cx,cy);
  c.lineTo(lx,ly);
  c.moveTo(cx,cy);
  c.lineTo(mx,my);
  c.stroke();
  
  ang=vectAngle(lx-cx,ly-cy,cx-mx,cy-my);

  ang=Math.floor((ang/(2.0*Math.PI))*360);

  c.font = "22px serif";
  c.fillText(ang,20, 20);

   /*
    
    // Empty cache
    for(var i=0;i<width;i++){
        pointHash[i]=[];
    }
    // World to the left and tiles to the right

//    toolcanvas.drawImage(tiles,0,0);
    c.drawImage(world,0,0);

    c.fillStyle="#000";
    //c.fillRect(500,100,4,4);

    var mapdata=c.getImageData(0,0,width,height).data;

    var ystart=0;
    var xstart=0;
    var xend=width-1;
    var yend=height-1;
    var scale=1;
    var xoffs=0;

    var bitvalues=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    for(var py=ystart;py<yend;py++){
        for(var px=xstart;px<xend;px++){
            var bitvalue=(imgToBits(mapdata,px,py,2,80));
            bitvalues[bitvalue]++;
            if(bitvalue==3) makesegment(px,py,px+1,py);     // Straight Horizontal Top
            if(bitvalue==5) makesegment(px,py,px,py+1);     // Straight Vertical Left
            if(bitvalue==6||bitvalue==7||bitvalue==14) makesegment(px,py+1,px+1,py);
            if(bitvalue==9||bitvalue==11||bitvalue==13) makesegment(px,py,px+1,py+1);          
            if(bitvalue==10) makesegment(px+1,py,px+1,py+1);    // Straight Vertical Right
            if(bitvalue==12) makesegment(px,py+1,px+1,py+1);    // Straight Horizontal Bottom
        }
    }

    c.clearRect(0,0,2050,1002);

    var paths=[];

    // We want a fast algorithm for joining segments
    for(segment of segments){
        // Visit all unvisited segments 
        if(segment.visited==false){
            // Start new path and assign current coordinates that we are matching
            segment.visited=true;
            var path=collatepoints(segment.x1,segment.y1);
            var after=collatepoints(segment.x2,segment.y2);
            path.reverse();
            path.push(segment);
            path=path.concat(after);

            path.color=randomColor();            

            // Path is ready
            paths.push(path);
        }
    }

    // drawPaths(paths,xoffs,0,xstart,ystart,scale)

    var finishedpaths=[];

    // Remove looping paths (this includes small loops and segments)
    for(var i=paths.length-1;i>0;i--){
        var path=paths[i];
            if(path[0].x1==path[path.length-1].x2&&path[0].y1==path[path.length-1].y2){
                var finishedpath=paths.splice(i,1);
                finishedpaths.push(finishedpath);
            }else if(path.length<10){
                paths.splice(i,1);
            }
    }

    // Find corresponding segments that end in the same place as this segment starts or vice versa
    for(var removalcnt=0;removalcnt<path.length;removalcnt++){
        var matches=findmatch(paths);
        if(matches!=false){
            if(matches.kind==1){
                // Reverse other
                paths[matches.other].reverse();
            }else if(matches.kind==-1){
                // Reverse path
                paths[matches.path].reverse();
            }  
            
            var gurk=paths[matches.other].concat(paths[matches.path]);
            if(matches.other>matches.path){
                paths.splice(matches.other,1);
                paths.splice(matches.path,1);
            }else{
                paths.splice(matches.path,1);
                paths.splice(matches.other,1);        
            }
            //gurk.color="#f45"; //randomColor();
            gurk.color=randomColor();
            paths.push(gurk);
        }else{
            break;
        }
    }

    // Add finished paths back to main path object
    for(path of finishedpaths)
    {
        paths.push(path[0]);
    }

    // Prepare path data for each path
    for(path of paths){
        var minx=500000;
        var maxx=-500000;
        var miny=500000;
        var maxy=-500000;
        for(segment of path){
            minx=Math.min(minx,Math.min(segment.x1,segment.x2));
            maxx=Math.max(maxx,Math.max(segment.x1,segment.x2));
            miny=Math.min(miny,Math.min(segment.y1,segment.y2));
            maxy=Math.max(maxy,Math.max(segment.y1,segment.y2));
        }
        path.minx=minx;
        path.miny=miny;
        path.maxx=maxx;
        path.maxy=maxy;

        path.area=(maxx-minx)*(maxy-miny);
    }

    // We remove all paths with an area smaller than treshold area or smaller than x points
    for(var i=paths.length-1;i>0;i--){
        var path=paths[i];
            if(path.length<10||path.area<400){
                paths.splice(i,1);
            }
    }

    // Reduce points based on angle


    // Idea is to turn the spline into a bezier curve

    // Draw Bounding Boxes
    c.setLineDash([2, 2]);
    c.strokeStyle="#888";
    c.beginPath();
    for(path of paths){
        c.moveTo(path.minx,path.miny);
        c.lineTo(path.maxx,path.miny);
        c.moveTo(path.minx,path.maxy);
        c.lineTo(path.maxx,path.maxy);
        c.moveTo(path.minx,path.miny);
        c.lineTo(path.minx,path.maxy);
        c.moveTo(path.maxx,path.miny);
        c.lineTo(path.maxx,path.maxy);
    }
    c.stroke();
    c.setLineDash([]);

    // Draw each path
    for(path of paths){
        console.log(path);
        c.strokeStyle=path.color;
        c.fillStyle=path.color;            
        c.beginPath();
        c.moveTo(xoffs+((path[0].x1-xstart)*scale),(path[0].y1-ystart)*scale);
        for(segment of path){
            c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
        }
        c.fill();
//        c.stroke();        
    }

    */

}

var mx=40,my=40;
function mouseMove(e)
{
    var rect = document.getElementById(e.target.id).getBoundingClientRect();

    mx=(e.clientX-rect.left);
    my=(e.clientY-rect.top);

    updatestate();
}

		</script>
</head>
<body onload="zetup();">

<!--  <button onclick="Export();">Export</button>-->
  <div id="wrapper">
 	<canvas id="myCanvas" width="4096" height="2048" style="border:1px solid #000000;" onmousemove="mouseMove(event);" ></canvas> 
  </div>
</body>