<!DOCTYPE html>
<html>
<head>
    <style>
        #wrapper{
            display:grid;
            grid-template-areas: "main tools";
        }

        #myCanvas{
            grid-area:main;
        }

        #toolsCanvas{
            grid-area:tools;
        }
        
    </style>
    <script>//document.write("<script type='text/javascript' src='helperFunction/hexcolors.js?t=" + Date.now() + "'><\/script>");</script>
		<script>
var c;
var mx,my,mb=0;
var world = new Image();

function zetup()
{
    var cc = document.getElementById("myCanvas");
    c = cc.getContext("2d");

    world.src = 'data/Equirectangular2.png';
    world.onload = function () {
        updatestate();
    };    
}

// We make a bit number if byte value is over treshold
function imgToBits(imgdata,px,py,comp,treshold)
{
    var num=0;
    var index=((py*width)+px)*4;
    var yadd=width*4;
    if(imgdata[index+comp]>treshold) num+=1;
    if(imgdata[index+comp+4]>treshold) num+=2;
    if(imgdata[index+comp+yadd]>treshold) num+=4;
    if(imgdata[index+comp+yadd+4]>treshold) num+=8;
    return num;
}

var width=2048;
var height=1000;

var segments=[];
var paths=[];
var pointHash=[];

function makesegment(px1,py1,px2,py2)
{
    var segment={id:segments.length,x1:px1,y1:py1,x2:px2,y2:py2,visited:false};
    addHash(px1,segment);
    addHash(px2,segment);
    segments.push(segment);
}

// We do not add duplicates of same segment to cache
function addHash(coord,item)
{
    for(pnt of pointHash[coord]){
        if(pnt.id==item.id) return false;
    }
    pointHash[coord].push(item);
}

function updatestate()
{
    // Empty cache
    for(var i=0;i<width;i++){
        pointHash[i]=[];
    }
    // World to the left and tiles to the right

//    toolcanvas.drawImage(tiles,0,0);
    c.drawImage(world,0,0);

    c.fillStyle="#000";
    //c.fillRect(500,100,4,4);

    var mapdata=c.getImageData(0,0,width,height).data;

    var ystart=0;
    var xstart=0;
    var xend=width-1;
    var yend=height-1;
    var scale=1;
    var xoffs=0;

    var bitvalues=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    for(var py=ystart;py<yend;py++){
        for(var px=xstart;px<xend;px++){
            var bitvalue=(imgToBits(mapdata,px,py,2,80));
            bitvalues[bitvalue]++;
            if(bitvalue==3) makesegment(px,py,px+1,py);     // Straight Horizontal Top
            if(bitvalue==5) makesegment(px,py,px,py+1);     // Straight Vertical Left
            if(bitvalue==6||bitvalue==7||bitvalue==14) makesegment(px,py+1,px+1,py);
            if(bitvalue==9||bitvalue==11||bitvalue==13) makesegment(px,py,px+1,py+1);          
            if(bitvalue==10) makesegment(px+1,py,px+1,py+1);    // Straight Vertical Right
            if(bitvalue==12) makesegment(px,py+1,px+1,py+1);    // Straight Horizontal Bottom
        }
    }

    c.clearRect(0,0,2048,1000);

    var paths=[];

    // We want a fast algorithm for joining segments

    for(segment of segments){
    //for(var j=0;j<100;j++){
        //var segment=segments[j];
        // Visit all unvisited segments 
        if(segment.visited==false){
            // Start new path and assign current coordinates that we are matching
            var path=[];
            segment.visited=true;
            path.push(segment);            
            var currx=segment.x2;
            var curry=segment.y2;
            var currid=segment.id;

            do{
                var foundcnt=0;
                var founditem=null;
                var items=[];

                for(point of pointHash[currx]){
                    if(((point.x1==currx&&point.y1==curry)||(point.x2==currx&&point.y2==curry))){
                        if(point.visited==false){
                            foundcnt++;
                            founditem=point;
                        }
                    }
                }

                if(foundcnt==0){
                    // Match not found i.e. end of path or error
                    console.log("NF",currx,curry);
                }else if(foundcnt>2){
                    // Branching path i.e. split points
                    console.log("BR ",currx,curry,items);
                }else{
                    path.push(founditem);
                    founditem.visited=true;
                    // Starting point of segment found or ending point of segment found
                    if(founditem.y1==curry&&founditem.x1==currx){
                        currx=founditem.x2;
                        curry=founditem.y2;
                        currid=founditem.id;
                        // console.log("EP");
                    }else{
                        currx=founditem.x1;
                        curry=founditem.y1;
                        currid=founditem.id;                    
                        // console.log("SP",currx,curry,founditem);
                        /*
                        for(segm of segments){
                            if(segm.x1==currx&&segm.y1==curry){
                                console.log("found x1",segm);
                            }
                            if(segm.x2==currx&&segm.y2==curry){
                                console.log("found x2",segm);
                            }
                        }
                        */
                    }
                }

            }while(foundcnt==1);

            // Path is ready
            paths.push(path);

        }
    }    

/*
    // Draw all segments
    c.strokeStyle="#000";
    c.beginPath();
    for(segment of segments){

        c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
        c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
    }
    c.stroke();
*/

    // Draw each path
    for(path of paths){
        if(path.length==1){
            c.strokeStyle="#f00";        
        }else{
            var R=Math.floor(Math.random()*255);
            var G=Math.floor(Math.random()*255);
            var B=Math.floor(Math.random()*255);

            c.strokeStyle="RGB("+R+","+G+","+B+")";        
        }
        c.beginPath();
        for(segment of path){
            c.moveTo(xoffs+((segment.x1-xstart)*scale),(segment.y1-ystart)*scale);
            c.lineTo(xoffs+((segment.x2-xstart)*scale),(segment.y2-ystart)*scale);    
        }
        c.stroke();    
    }

    console.log(paths.length);

}

		</script>
</head>
<body onload="zetup();">

<!--  <button onclick="Export();">Export</button>-->
  <div id="wrapper">
 	<canvas id="myCanvas" width="2048" height="1344" style="border:1px solid #000000;"></canvas> 
  </div>
</body>